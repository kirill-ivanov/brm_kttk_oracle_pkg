CREATE OR REPLACE PACKAGE PK09_INVOICE
IS
    --
    -- Пакет для работы с объектом "ПОЗИЦИЯ СЧЕТА-ФАКТУРЫ", таблицы:
    -- invoice_item_t
    --
    -- ==============================================================================
    c_PkgName   constant varchar2(30) := 'PK09_INVOICE';
    -- ==============================================================================
    c_RET_OK    constant integer := 0;
    c_RET_ER		constant integer :=-1;
    
    type t_refc is ref cursor;
    
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Функции расчета/выделения налога
    -- 
    -- возвращает сумму налога на указанную сумму (без налога)
    FUNCTION Calc_tax(
                  p_taxfree_total IN NUMBER,  -- сумма без налога
                  p_tax_rate      IN NUMBER   -- ставка налога в процентах
               ) RETURN NUMBER DETERMINISTIC;
               
    -- возвращает сумму налога из указанной суммы (с налогом)
    FUNCTION Allocate_tax(
                  p_total      IN NUMBER,     -- сумма с налогом
                  p_tax_rate   IN NUMBER      -- ставка налога в процентах
               ) RETURN NUMBER DETERMINISTIC;
    
    -- Полная сумма начислений с налогами -------------
    FUNCTION Calc_total(
                  p_amount   IN NUMBER,     -- сумма с налогом
                  p_tax_incl IN CHAR,       -- налог включен в сумму для расчетов = 'Y'/'N'
                  p_vat      IN NUMBER      -- ставка НДС
               ) RETURN NUMBER DETERMINISTIC;

    -- Сумма начислений без налогов -------------------
    FUNCTION Calc_gross(
                  p_amount   IN NUMBER,     -- сумма с налогом
                  p_tax_incl IN CHAR,       -- налог включен в сумму для расчетов = 'Y'/'N'
                  p_vat      IN NUMBER      -- ставка НДС
               ) RETURN NUMBER DETERMINISTIC;

    -- Полная сумма налога на проведенные начисления --
    FUNCTION Calc_tax(
                  p_amount   IN NUMBER,     -- сумма с налогом
                  p_tax_incl IN CHAR,       -- налог включен в сумму для расчетов = 'Y'/'N'
                  p_vat      IN NUMBER      -- ставка НДС
               ) RETURN NUMBER DETERMINISTIC;
    
        
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Получить имя позиции счета-фактуры для услуги
    --   - при ошибке выставляет исключение
    FUNCTION Get_item_name (
                  p_service_id  IN INTEGER,
                  p_account_id  IN INTEGER,
                  p_contract_id IN INTEGER,
                  p_customer_id IN INTEGER
               ) RETURN VARCHAR2;

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Расчитать позицию счета-фактуры, для регулярного счета 'B'
    -- item-ы распределяются на invoice_item-ы по услугам
    -- по правилу 7701 (INV_STD):
    --   период invoice_item соответствует мин/макс диапазону itemo-ов
    -- Возвращает:
    --   - положительное - ID invoice_item, 
    --   - при ошибке выставляет исключение
    PROCEDURE Calc_inv_item_std (
                   p_inv_item_no   IN OUT INTEGER, -- номер строки в счете фактуре
                   p_bill_id       IN INTEGER,   -- ID позиции счета
                   p_rep_period_id IN INTEGER,   -- ID отчетного периода счета
                   p_service_id    IN INTEGER,   -- ID услуги
                   p_inv_item_name IN VARCHAR2,  -- имя строки в счете фактуре
                   p_vat           IN NUMBER,    -- ставка налога в процентах
                   p_bill_type     IN VARCHAR2   -- тип счета
               );

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Расчитать позицию счета-фактуры, для счета,
    -- По правилам:
    -- 7702 (RULE_EXT) - период строки соответствует периоду счета
    -- 7703 (RULE_PER) - группировка строк разделно по биллинговым периодам
    -- Если p_date_from не задан то применяем правило 7702:
    --    item-ы счета по услуге, оказанной в разных периодах распределяются 
    --    на invoice_item, биллингового периода
    -- Если p_date_from задан то применяем правило 7703:
    --    item-ы счета за указанный период распределяются на invoice_item этого периода
    -- Возвращает:
        --   - положительное - ID invoice_item, 
        --   - при ошибке выставляет исключение
    PROCEDURE Calc_inv_item_ext (
                   p_inv_item_no   IN OUT INTEGER, -- номер строки в счете фактуре
                   p_bill_id       IN INTEGER,     -- ID позиции счета
                   p_rep_period_id IN INTEGER,     -- ID отчетного периода счета
                   p_service_id    IN INTEGER,     -- ID услуги
                   p_inv_item_name IN VARCHAR2,    -- имя строки в счете фактуре
                   p_vat           IN NUMBER,      -- ставка налога в процентах
                   p_date_from     IN DATE DEFAULT NULL  -- дата начала оказания услуги, 
               );  -- в с-ф могут входить услуги оказанные в разных периодах (довыставление)

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Расчитать позицию счета-фактуры для регулярного счета, типа 'B',
    -- Правило: 7704 - группировка строк по компонентам услуги. для договоров местного присоединения
    -- item-ы по одной услуги группируются по компонентам услуги текущего периода,
    -- не зависимо от даты оказания услуги
        --   - положительное - ID invoice_item, 
        --   - при ошибке выставляет исключение
    PROCEDURE Calc_inv_item_subsrv_std (
                   p_inv_item_no   IN OUT INTEGER, -- номер строки в счете фактуре
                   p_bill_id       IN INTEGER,     -- ID позиции счета
                   p_rep_period_id IN INTEGER,     -- ID отчетного периода счета
                   p_service_id    IN INTEGER,     -- ID услуги
                   p_vat           IN NUMBER       -- ставка налога в процентах
               );
    
    -- Версия допускающая группировку по биллинговым периодам (для страховки)
    PROCEDURE Calc_inv_item_subsrv_ext (
                   p_inv_item_no   IN OUT INTEGER, -- номер строки в счете фактуре
                   p_bill_id       IN INTEGER,     -- ID позиции счета
                   p_rep_period_id IN INTEGER,     -- ID отчетного периода счета
                   p_service_id    IN INTEGER,     -- ID услуги
                   p_vat           IN NUMBER,     -- ставка налога в процентах
                   p_date_from     IN DATE DEFAULT NULL  -- дата начала оказания услуги,     
               );   -- в с-ф могут входить услуги оказанные в разных периодах (довыставление)
    
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Расчитать позицию счета-фактуры  для РЖД л/с MS107643
    -- + item-ы распределяются на invoice_item-ы по услугам,
    -- + скидки выделяются в отдельные invoice_item-ы по услугам
    -- + период invoice_item строго соответствует периоду счета
    -- по правилу 7707 (INV_RZD):
    PROCEDURE Calc_inv_item_rzd (
                   p_inv_item_no   IN OUT INTEGER, -- номер строки в счете фактуре
                   p_bill_id       IN INTEGER,   -- ID позиции счета
                   p_rep_period_id IN INTEGER,   -- ID отчетного периода счета
                   p_service_id    IN INTEGER,   -- ID услуги
                   p_inv_item_name IN VARCHAR2,  -- имя строки в счете фактуре
                   p_vat           IN NUMBER     -- ставка налога в процентах
               );
    
    -- Расчитать счет-фактуру
    --   - величину начислений по позиции, включая налог 
    --   - при ошибке выставляет исключение
    FUNCTION Calc_invoice (
                   p_bill_id       IN INTEGER,   -- ID позиции счета
                   p_rep_period_id IN INTEGER    -- ID отчетного периода счета
               ) RETURN NUMBER;
               
    -- найти все позиции указанного счета-фактуры
    --   - положительное - кол-во выбранных записей
    --   - при ошибке выставляет исключение
    FUNCTION Invoice_items_list( 
                   p_recordset    OUT t_refc, 
                   p_bill_id       IN INTEGER,   -- ID счета
                   p_rep_period_id IN INTEGER    -- ID отчетного периода счета
               ) RETURN INTEGER;
    
    -- Удалить все позиции указанного счета-фактуры
    --   - положительное - кол-во удаленных записей
    --   - при ошибке выставляет исключение
    FUNCTION Delete_invoice_items (
                   p_bill_id       IN INTEGER,   -- ID счета
                   p_rep_period_id IN INTEGER    -- ID отчетного периода счета
               ) RETURN INTEGER;
    
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Список правил формирования строк счтов-фактур
    PROCEDURE Invoice_rules_list( 
                   p_recordset IN OUT SYS_REFCURSOR
               );
  
    -- Редактирование позции счет-фактуры
    PROCEDURE Edit_invoice_item_name ( 
              p_bill_id      IN    INTEGER,
              p_period_id    IN    INTEGER,
              p_invoice_id   IN    INTEGER,
              p_name         IN    VARCHAR2
    );
      
END PK09_INVOICE;
/
CREATE OR REPLACE PACKAGE BODY PK09_INVOICE
IS

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Получить имя позиции счета-фактуры для услуги
--   - при ошибке выставляет исключение
FUNCTION Get_item_name (
              p_service_id  IN INTEGER,
              p_account_id  IN INTEGER,
              p_contract_id IN INTEGER,
              p_customer_id IN INTEGER
           ) RETURN VARCHAR2
IS
    v_prcName       CONSTANT VARCHAR2(30) := 'Get_item_name';
    v_item_name     INVOICE_ITEM_T.INV_ITEM_NAME%TYPE;
BEGIN
    WITH SA AS (
        SELECT SERVICE_ID, SRV_NAME, IDX
          FROM (
            SELECT CASE
                     WHEN SA.ACCOUNT_ID  IS NOT NULL THEN 1
                     WHEN SA.CONTRACT_ID IS NOT NULL THEN 2
                     WHEN SA.CUSTOMER_ID IS NOT NULL THEN 3
                     ELSE 0
                   END IDX,
                   SA.SERVICE_ID, SA.SRV_NAME 
              FROM SERVICE_ALIAS_T SA
             WHERE SA.SERVICE_ID    = p_service_id
               AND ( SA.ACCOUNT_ID  = p_account_id  OR
                     SA.CONTRACT_ID = p_contract_id OR
                     SA.CUSTOMER_ID = p_customer_id
                   )
              ORDER BY 1 
        )WHERE ROWNUM = 1
    )
    SELECT NVL(SRV_NAME, SERVICE) SERVICE 
      INTO v_item_name
      FROM SA, SERVICE_T S
     WHERE S.SERVICE_ID = SA.SERVICE_ID(+)
       AND S.SERVICE_ID = p_service_id;
     RETURN v_item_name;
EXCEPTION
    WHEN OTHERS THEN
        Pk01_Syslog.raise_Exception('ERROR', c_PkgName||'.'||v_prcName );
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Функции расчета/выделения налога
-- (на всякий случай приводим входящуюю величину к формату: руб.коп)

-- возвращает сумму налога на указанную сумму (без налога)
FUNCTION Calc_tax(
              p_taxfree_total IN NUMBER,  -- сумма без налога
              p_tax_rate      IN NUMBER   -- ставка налога в процентах
           ) RETURN NUMBER DETERMINISTIC
IS
    v_total NUMBER := ROUND(p_taxfree_total, 2);-- xxxxx.xx (руб.коп)
BEGIN    
    RETURN  ROUND(v_total * p_tax_rate / 100, 2);
END;

-- возвращает сумму налога из указанной суммы (с налогом)
FUNCTION Allocate_tax(
              p_total      IN NUMBER,   -- сумма с налогом
              p_tax_rate   IN NUMBER    -- ставка налога в процентах
           ) RETURN NUMBER DETERMINISTIC
IS
    v_total NUMBER := ROUND(p_total, 2);-- xxxxx.xx (руб.коп)
BEGIN    
    RETURN  v_total - ROUND(v_total /(1 + p_tax_rate / 100), 2);
END;

-- Полная сумма начислений с налогами -------------
FUNCTION Calc_total(
              p_amount   IN NUMBER,     -- сумма с налогом
              p_tax_incl IN CHAR,       -- налог включен в сумму для расчетов = 'Y'/'N'
              p_vat      IN NUMBER      -- ставка НДС
           ) RETURN NUMBER DETERMINISTIC
IS
    v_amount NUMBER := ROUND(p_amount, 2); -- xxxxx.xx (руб.коп)
BEGIN    
    IF p_tax_incl = PK00_CONST.c_RATEPLAN_TAX_INCL THEN      -- налог включен в начисленную сумму
        RETURN v_amount;
    ELSIF p_tax_incl = PK00_CONST.c_RATEPLAN_TAX_NOT_INCL THEN -- налог не включен
        RETURN v_amount + PK09_INVOICE.Calc_tax(v_amount, p_vat);
    ELSE -- защита от ошибок
        RETURN NULL;
    END IF;
END;

-- Сумма начислений без налогов -------------------
FUNCTION Calc_gross(
              p_amount   IN NUMBER,     -- сумма с налогом
              p_tax_incl IN CHAR,       -- налог включен в сумму для расчетов = 'Y'/'N'
              p_vat      IN NUMBER      -- ставка НДС
           ) RETURN NUMBER DETERMINISTIC
IS
    v_amount NUMBER := ROUND(p_amount, 2); -- xxxxx.xx (руб.коп)
BEGIN
    IF p_tax_incl = PK00_CONST.c_RATEPLAN_TAX_INCL THEN      -- налог включен в начисленную сумму
        RETURN v_amount - PK09_INVOICE.Allocate_tax(v_amount, p_vat);
    ELSIF p_tax_incl = PK00_CONST.c_RATEPLAN_TAX_NOT_INCL THEN -- налог не включен
        RETURN v_amount;
    ELSE -- защита от ошибок
        RETURN NULL;
    END IF;
END;

-- Полная сумма налога на проведенные начисления --
FUNCTION Calc_tax(
              p_amount   IN NUMBER,     -- сумма с налогом
              p_tax_incl IN CHAR,       -- налог включен в сумму для расчетов = 'Y'/'N'
              p_vat      IN NUMBER      -- ставка НДС
           ) RETURN NUMBER DETERMINISTIC
IS
BEGIN    
    IF p_tax_incl = PK00_CONST.c_RATEPLAN_TAX_INCL THEN      -- налог включен в начисленную сумму
        RETURN PK09_INVOICE.Allocate_tax(p_amount, p_vat);
    ELSIF p_tax_incl = PK00_CONST.c_RATEPLAN_TAX_NOT_INCL THEN -- налог не включен
        RETURN PK09_INVOICE.Calc_tax(p_amount, p_vat);
    ELSE -- защита от ошибок
        RETURN NULL;
    END IF;
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Расчитать позицию счета-фактуры, для регулярного счета 'B'
-- item-ы распределяются на invoice_item-ы по услугам
-- по правилу 7701 (INV_STD):
--   период invoice_item соответствует мин/макс диапазону itemo-ов
-- Возвращает:
--   - положительное - ID invoice_item, 
--   - при ошибке выставляет исключение
PROCEDURE Calc_inv_item_std (
               p_inv_item_no   IN OUT INTEGER, -- номер строки в счете фактуре
               p_bill_id       IN INTEGER,   -- ID позиции счета
               p_rep_period_id IN INTEGER,   -- ID отчетного периода счета
               p_service_id    IN INTEGER,   -- ID услуги
               p_inv_item_name IN VARCHAR2,  -- имя строки в счете фактуре
               p_vat           IN NUMBER,    -- ставка налога в процентах
               p_bill_type     IN VARCHAR2   -- тип счета
           ) 
IS
    v_prcName       CONSTANT VARCHAR2(30) := 'Calc_inv_item_std';
    v_inv_item_id   INTEGER;
    v_count         INTEGER;
    --
BEGIN
    -- - - - - - - - - - - - - - - - - - - - - - - - --
    -- вычисляем id строки счета-фактуры от id строки счета
    v_inv_item_id := PK02_POID.Next_invoice_item_id;
        
    -- формируем строку счета-фактуры
    INSERT INTO INVOICE_ITEM_T (
       BILL_ID, REP_PERIOD_ID,
       INV_ITEM_ID, INV_ITEM_NO, SERVICE_ID, INV_ITEM_NAME, 
       VAT,         -- ставка НДС в процентах
       TOTAL,       -- сумма начислений с налогом
       GROSS,       -- сумма начислений без налога
       TAX,         -- сумма налога
       DATE_FROM, DATE_TO
    )
    SELECT 
         p_bill_id, p_rep_period_id, v_inv_item_id, p_inv_item_no, p_service_id, 
         p_inv_item_name, p_vat,
         ROUND(SUM(TOTAL),2), 
         ROUND(SUM(GROSS),2), 
         ROUND(SUM(TAX),2), 
         MIN(DATE_FROM), MAX(DATE_TO)
      FROM (
        SELECT  
           -- Полная сумма начислений с налогами -------------
           Calc_total( AMOUNT, TAX_INCL, p_vat ) TOTAL, 
           -- Сумма начислений без налогов -------------------
           Calc_gross( AMOUNT, TAX_INCL, p_vat ) GROSS, 
           -- Полная сумма налога на проведенные начисления --
           Calc_tax( AMOUNT, TAX_INCL, p_vat ) TAX,
           -- минимальна и максимальные даты оказания услуги --
           DATE_FROM, DATE_TO
        FROM (
          SELECT TAX_INCL, 
             SUM(BILL_TOTAL) AMOUNT, 
             -- Н.Фоменко сказала, что так сказала бухгалтерия 31.10.2016
             CASE
               WHEN p_bill_type IN ( 'B', 'D' )
                 THEN MIN(GREATEST(P.PERIOD_FROM, TRUNC(O.DATE_FROM)))
               ELSE   MIN(GREATEST(TRUNC(I.DATE_FROM,'mm'), TRUNC(O.DATE_FROM)))
             END  DATE_FROM,
             CASE
               WHEN p_bill_type IN ( 'B', 'D' )
                 THEN MAX(LEAST(P.PERIOD_TO, O.DATE_TO))
               ELSE   MAX(LEAST((ADD_MONTHS(TRUNC(I.DATE_TO,'mm'),1)-1/86400), O.DATE_TO))
             END DATE_TO
             --
          FROM ITEM_T I, ORDER_T O, PERIOD_T P
           WHERE I.BILL_ID       = p_bill_id
             AND I.REP_PERIOD_ID = p_rep_period_id
             AND I.ORDER_ID      = O.ORDER_ID
             AND I.SERVICE_ID    = p_service_id
             AND P.PERIOD_ID     = I.REP_PERIOD_ID
          GROUP BY TAX_INCL
      )
    );
    v_count := SQL%ROWCOUNT;
    IF v_count = 1 THEN
        -- проставляем признак вхождения в счет-фактуру, строкам счета (item)
        UPDATE ITEM_T 
           SET INV_ITEM_ID   = v_inv_item_id
         WHERE BILL_ID       = p_bill_id
           AND REP_PERIOD_ID = p_rep_period_id
           AND SERVICE_ID    = p_service_id;
          
        -- переходим к следующей позиции в счете
        p_inv_item_no := p_inv_item_no + 1;
        --
    END IF;   
EXCEPTION
    WHEN OTHERS THEN
        Pk01_Syslog.raise_Exception('ERROR. Bill_id='||p_bill_id
                                  ||', service_id='||p_service_id, c_PkgName||'.'||v_prcName );
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Расчитать позицию счета-фактуры, для счета,
-- По правилам:
-- 7702 (RULE_EXT) - период строки соответствует периоду счета
-- 7703 (RULE_PER) - группировка строк разделно по биллинговым периодам
-- Если p_date_from не задан то применяем правило 7702:
--    item-ы счета по услуге, оказанной в разных периодах распределяются 
--    на invoice_item, биллингового периода
-- Если p_date_from задан то применяем правило 7703:
--    item-ы счета за указанный период распределяются на invoice_item этого периода
-- Возвращает:
    --   - положительное - ID invoice_item, 
    --   - при ошибке выставляет исключение
PROCEDURE Calc_inv_item_ext (
               p_inv_item_no   IN OUT INTEGER, -- номер строки в счете фактуре
               p_bill_id       IN INTEGER,   -- ID позиции счета
               p_rep_period_id IN INTEGER,   -- ID отчетного периода счета
               p_service_id    IN INTEGER,   -- ID услуги
               p_inv_item_name IN VARCHAR2,  -- имя строки в счете фактуре
               p_vat           IN NUMBER,    -- ставка налога в процентах
               p_date_from     IN DATE DEFAULT NULL  -- дата начала оказания услуги, 
           )                                 -- в с-ф могут входить услуги оказанные 
IS                                           -- в разных периодах (довыставление)
    v_prcName       CONSTANT VARCHAR2(30) := 'Calc_inv_item_ext';
    v_date_from     DATE;
    v_date_to       DATE;
    v_inv_item_id   INTEGER;
    v_count         INTEGER;
    --
BEGIN
    IF p_date_from IS NULL THEN  
        -- биллинговый период
        v_date_from := Pk04_Period.Period_from(p_rep_period_id);
        v_date_to   := Pk04_Period.Period_to(p_rep_period_id);
    ELSE
        -- указанный период
        v_date_from := TRUNC(p_date_from,'mm');
        v_date_to   := ADD_MONTHS(v_date_from,1)-1/86400;
    END IF;  
    
    -- - - - - - - - - - - - - - - - - - - - - - - - --
    -- вычисляем id строки счета-фактуры от id строки счета
    v_inv_item_id := PK02_POID.Next_invoice_item_id;
        
    -- формируем строку счета-фактуры
    INSERT INTO INVOICE_ITEM_T (
       BILL_ID, REP_PERIOD_ID,
       INV_ITEM_ID, INV_ITEM_NO, SERVICE_ID, INV_ITEM_NAME, 
       VAT,         -- ставка НДС в процентах
       TOTAL,       -- сумма начислений с налогом
       GROSS,       -- сумма начислений без налога
       TAX,         -- сумма налога
       DATE_FROM, DATE_TO
    )
    SELECT 
         p_bill_id, p_rep_period_id, v_inv_item_id, p_inv_item_no, p_service_id, 
         p_inv_item_name, p_vat,
         ROUND(SUM(TOTAL),2), 
         ROUND(SUM(GROSS),2), 
         ROUND(SUM(TAX),2), 
         MIN(DATE_FROM), MAX(DATE_TO)
      FROM (
        SELECT  
           -- Полная сумма начислений с налогами -------------
           Calc_total( AMOUNT, TAX_INCL, p_vat ) TOTAL, 
           -- Сумма начислений без налогов -------------------
           Calc_gross( AMOUNT, TAX_INCL, p_vat ) GROSS, 
           -- Полная сумма налога на проведенные начисления --
           Calc_tax( AMOUNT, TAX_INCL, p_vat ) TAX,
           -- минимальна и максимальные даты оказания услуги --
           DATE_FROM, DATE_TO
        FROM (
          SELECT TAX_INCL, 
             SUM(BILL_TOTAL) AMOUNT, 
             MIN(GREATEST(v_date_from, TRUNC(O.DATE_FROM))) DATE_FROM,
             MAX(LEAST(v_date_to, O.DATE_TO)) DATE_TO
          FROM ITEM_T I, ORDER_T O
           WHERE I.BILL_ID = p_bill_id
             AND I.REP_PERIOD_ID = p_rep_period_id
             AND I.ORDER_ID = O.ORDER_ID
             AND I.SERVICE_ID = p_service_id
             AND (p_date_from IS NULL OR TRUNC(I.DATE_FROM,'mm') = v_date_from)
          GROUP BY TAX_INCL
      )
    );
    v_count := SQL%ROWCOUNT;
    IF v_count = 1 THEN
        -- проставляем признак вхождения в счет-фактуру, строкам счета (item)
        UPDATE ITEM_T 
           SET INV_ITEM_ID = v_inv_item_id
         WHERE BILL_ID = p_bill_id
           AND REP_PERIOD_ID = p_rep_period_id
           AND SERVICE_ID = p_service_id
           AND (p_date_from IS NULL OR TRUNC(DATE_FROM,'mm') = v_date_from);
          
        -- переходим к следующей позиции в счете
        p_inv_item_no := p_inv_item_no + 1;
        --
    END IF;   
EXCEPTION
    WHEN OTHERS THEN
        Pk01_Syslog.raise_Exception('ERROR. Bill_id='||p_bill_id
                                  ||', service_id='||p_service_id, c_PkgName||'.'||v_prcName );
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Расчитать позицию счета-фактуры для регулярного счета, типа 'B',
-- Правило: 7704 - группировка строк по компонентам услуги. для договоров местного присоединения
-- item-ы по одной услуги группируются по компонентам услуги текущего периода,
-- не зависимо от даты оказания услуги
    --   - положительное - ID invoice_item, 
    --   - при ошибке выставляет исключение
PROCEDURE Calc_inv_item_subsrv_std (
               p_inv_item_no   IN OUT INTEGER,   -- номер строки в счете фактуре
               p_bill_id       IN INTEGER,   -- ID позиции счета
               p_rep_period_id IN INTEGER,   -- ID отчетного периода счета
               p_service_id    IN INTEGER,   -- ID услуги
               p_vat           IN NUMBER     -- ставка налога в процентах
           ) 
IS
    v_prcName       CONSTANT VARCHAR2(30) := 'Calc_inv_item_subsrv_std';
    v_inv_item_id   INTEGER;
    --
BEGIN
    FOR c_item IN (
        SELECT 
             SUBSERVICE_ID,         
             ROUND(SUM(TOTAL),2) SUM_TOTAL, 
             ROUND(SUM(GROSS),2) SUM_GROSS, 
             ROUND(SUM(TAX),2)   SUM_TAX, 
             MIN(DATE_FROM)      DATE_FROM, 
             MAX(DATE_TO)        DATE_TO
          FROM (
            SELECT 
                 SUBSERVICE_ID,
                 -- Полная сумма начислений с налогами -------------
                 Calc_total( AMOUNT, TAX_INCL, p_vat ) TOTAL, 
                 -- Сумма начислений без налогов -------------------
                 Calc_gross( AMOUNT, TAX_INCL, p_vat ) GROSS, 
                 -- Полная сумма налога на проведенные начисления --
                 Calc_tax( AMOUNT, TAX_INCL, p_vat ) TAX,
                 -- минимальна и максимальные даты оказания услуги --
                 DATE_FROM, DATE_TO
              FROM (
                SELECT I.SUBSERVICE_ID, I.TAX_INCL, 
                   SUM(BILL_TOTAL) AMOUNT, 
                   -- Н.Фоменко сказала, что так сказала бухгалтерия 31.10.2016
                   MIN(GREATEST(TRUNC(I.DATE_FROM,'mm'), TRUNC(O.DATE_FROM))) DATE_FROM,
                   --MIN(GREATEST(P.PERIOD_FROM, TRUNC(O.DATE_FROM))) DATE_FROM,
                   MAX(LEAST((ADD_MONTHS(TRUNC(I.DATE_TO,'mm'),1)-1/86400), O.DATE_TO)) DATE_TO
                   --MAX(LEAST(P.PERIOD_TO, O.DATE_TO)) DATE_TO
                FROM ITEM_T I, ORDER_T O, PERIOD_T P
                 WHERE I.BILL_ID = p_bill_id
                   AND I.REP_PERIOD_ID = p_rep_period_id
                   AND I.ORDER_ID = O.ORDER_ID
                   AND I.SERVICE_ID = p_service_id
                GROUP BY I.SUBSERVICE_ID, I.TAX_INCL
            )
        )
        GROUP BY SUBSERVICE_ID
    )
    LOOP
        -- вычисляем id строки счета-фактуры от id строки счета
        v_inv_item_id := PK02_POID.Next_invoice_item_id;
        
        -- раздельно по компонентам услуги
        INSERT INTO INVOICE_ITEM_T (
           BILL_ID, REP_PERIOD_ID,
           INV_ITEM_ID, INV_ITEM_NO, SERVICE_ID, INV_ITEM_NAME, 
           VAT,         -- ставка НДС в процентах
           TOTAL,       -- сумма начислений с налогом
           GROSS,       -- сумма начислений без налога
           TAX,         -- сумма налога
           DATE_FROM, DATE_TO
        )
        SELECT 
             p_bill_id, p_rep_period_id, 
             v_inv_item_id, p_inv_item_no, p_service_id, 
             SS.SUBSERVICE INV_ITEM_NAME, p_vat,
             c_item.SUM_TOTAL, c_item.SUM_GROSS, c_item.SUM_TAX, 
             c_item.DATE_FROM, c_item.DATE_TO
          FROM SUBSERVICE_T SS
         WHERE SS.SUBSERVICE_ID = c_item.SUBSERVICE_ID;
        --
        -- проставляем признак вхождения в счет-фактуру, строкам счета (item)
        UPDATE ITEM_T 
           SET INV_ITEM_ID   = v_inv_item_id
         WHERE BILL_ID       = p_bill_id
           AND REP_PERIOD_ID = p_rep_period_id
           AND SERVICE_ID    = p_service_id
           AND SUBSERVICE_ID = c_item.SUBSERVICE_ID;
         
        -- переходим к следующей позиции в счете
        p_inv_item_no := p_inv_item_no + 1;
        --

    END LOOP;

EXCEPTION
    WHEN OTHERS THEN
        Pk01_Syslog.raise_Exception('ERROR. Bill_id='||p_bill_id
                                  ||', service_id='||p_service_id, c_PkgName||'.'||v_prcName );
END;

-- Версия допускающая группировку по биллинговым периодам (для страховки)
PROCEDURE Calc_inv_item_subsrv_ext (
               p_inv_item_no   IN OUT INTEGER,   -- номер строки в счете фактуре
               p_bill_id       IN INTEGER,   -- ID позиции счета
               p_rep_period_id IN INTEGER,   -- ID отчетного периода счета
               p_service_id    IN INTEGER,   -- ID услуги
               p_vat           IN NUMBER,     -- ставка налога в процентах
               p_date_from     IN DATE DEFAULT NULL  -- дата начала оказания услуги,     
           )                                 -- в с-ф могут входить услуги оказанные 
IS                                           -- в разных периодах (довыставление)
    v_prcName       CONSTANT VARCHAR2(30) := 'Calc_inv_item_subsrv_ext';
    v_date_from     DATE;
    v_date_to       DATE;
    v_inv_item_id   INTEGER;
    --
BEGIN
    IF p_date_from IS NULL THEN  
        -- биллинговый период
        v_date_from := Pk04_Period.Period_from(p_rep_period_id);
        v_date_to   := Pk04_Period.Period_to(p_rep_period_id);
    ELSE
        -- указанный период
        v_date_from := TRUNC(p_date_from,'mm');
        v_date_to   := ADD_MONTHS(v_date_from,1)-1/86400;
    END IF;

    FOR c_item IN (
        SELECT 
             SUBSERVICE_ID,         
             ROUND(SUM(TOTAL),2) SUM_TOTAL, 
             ROUND(SUM(GROSS),2) SUM_GROSS, 
             ROUND(SUM(TAX),2)   SUM_TAX, 
             MIN(DATE_FROM) DATE_FROM, 
             MAX(DATE_TO)   DATE_TO
          FROM (
            SELECT 
                 SUBSERVICE_ID,
                 -- Полная сумма начислений с налогами -------------
                 Calc_total( AMOUNT, TAX_INCL, p_vat ) TOTAL, 
                 -- Сумма начислений без налогов -------------------
                 Calc_gross( AMOUNT, TAX_INCL, p_vat ) GROSS, 
                 -- Полная сумма налога на проведенные начисления --
                 Calc_tax( AMOUNT, TAX_INCL, p_vat ) TAX,
                 -- минимальна и максимальные даты оказания услуги --
                 DATE_FROM, DATE_TO
              FROM (
                SELECT I.SUBSERVICE_ID, I.TAX_INCL, 
                   SUM(BILL_TOTAL) AMOUNT, 
                   MIN(GREATEST(v_date_from, TRUNC(O.DATE_FROM))) DATE_FROM,
                   MAX(LEAST(v_date_to, O.DATE_TO)) DATE_TO
                FROM ITEM_T I, ORDER_T O
                 WHERE I.BILL_ID = p_bill_id
                   AND I.REP_PERIOD_ID = p_rep_period_id
                   AND I.ORDER_ID = O.ORDER_ID
                   AND I.SERVICE_ID = p_service_id
                   AND (p_date_from IS NULL OR TRUNC(I.DATE_FROM,'mm') = v_date_from)
                GROUP BY I.SUBSERVICE_ID, I.TAX_INCL
            )
        )
        GROUP BY SUBSERVICE_ID
    )
    LOOP
        -- вычисляем id строки счета-фактуры от id строки счета
        v_inv_item_id := PK02_POID.Next_invoice_item_id;
        
        -- раздельно по компонентам услуги
        INSERT INTO INVOICE_ITEM_T (
           BILL_ID, REP_PERIOD_ID,
           INV_ITEM_ID, INV_ITEM_NO, SERVICE_ID, INV_ITEM_NAME, 
           VAT,         -- ставка НДС в процентах
           TOTAL,       -- сумма начислений с налогом
           GROSS,       -- сумма начислений без налога
           TAX,         -- сумма налога
           DATE_FROM, DATE_TO
        )
        SELECT 
             p_bill_id, p_rep_period_id, 
             v_inv_item_id, p_inv_item_no, p_service_id, 
             SS.SUBSERVICE INV_ITEM_NAME, p_vat,
             c_item.SUM_TOTAL, c_item.SUM_GROSS, c_item.SUM_TAX, 
             c_item.DATE_FROM, c_item.DATE_TO
          FROM SUBSERVICE_T SS
         WHERE SS.SUBSERVICE_ID = c_item.SUBSERVICE_ID;
        --
        -- проставляем признак вхождения в счет-фактуру, строкам счета (item)
        UPDATE ITEM_T 
           SET INV_ITEM_ID   = v_inv_item_id
         WHERE BILL_ID       = p_bill_id
           AND REP_PERIOD_ID = p_rep_period_id
           AND SERVICE_ID    = p_service_id
           AND SUBSERVICE_ID = c_item.SUBSERVICE_ID
           AND (p_date_from IS NULL OR TRUNC(DATE_FROM,'mm') = v_date_from);
         
        -- переходим к следующей позиции в счете
        p_inv_item_no := p_inv_item_no + 1;
        --
         
    END LOOP;

EXCEPTION
    WHEN OTHERS THEN
        Pk01_Syslog.raise_Exception('ERROR. Bill_id='||p_bill_id
                                  ||', service_id='||p_service_id, c_PkgName||'.'||v_prcName );
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Расчитать позицию счета-фактуры  для РЖД л/с MS107643
-- + item-ы распределяются на invoice_item-ы по услугам,
-- + скидки выделяются в отдельные invoice_item-ы по услугам
-- + период invoice_item строго соответствует периоду счета
-- по правилу 7707 (INV_RZD):
PROCEDURE Calc_inv_item_rzd (
               p_inv_item_no   IN OUT INTEGER, -- номер строки в счете фактуре
               p_bill_id       IN INTEGER,   -- ID позиции счета
               p_rep_period_id IN INTEGER,   -- ID отчетного периода счета
               p_service_id    IN INTEGER,   -- ID услуги
               p_inv_item_name IN VARCHAR2,  -- имя строки в счете фактуре
               p_vat           IN NUMBER     -- ставка налога в процентах
           ) 
IS
    v_prcName       CONSTANT VARCHAR2(30) := 'Calc_inv_item_rzd';
    v_inv_item_id   INTEGER;
    v_count         INTEGER;
    v_charge_type   VARCHAR2(20);
    --
BEGIN
    -- invoice_item формируется на service_id + subservice_id + charge_type
    FOR c_item IN (
        SELECT 
             SUBSERVICE_ID,
             CHARGE_TYPE,
             ROUND(SUM(TOTAL),2) SUM_TOTAL, 
             ROUND(SUM(GROSS),2) SUM_GROSS, 
             ROUND(SUM(TAX),2)   SUM_TAX, 
             MIN(DATE_FROM)      DATE_FROM, 
             MAX(DATE_TO)        DATE_TO
          FROM (
            SELECT 
                 SUBSERVICE_ID, CHARGE_TYPE,
                 -- Полная сумма начислений с налогами -------------
                 Calc_total( AMOUNT, TAX_INCL, p_vat ) TOTAL, 
                 -- Сумма начислений без налогов -------------------
                 Calc_gross( AMOUNT, TAX_INCL, p_vat ) GROSS, 
                 -- Полная сумма налога на проведенные начисления --
                 Calc_tax( AMOUNT, TAX_INCL, p_vat ) TAX,
                 -- минимальна и максимальные даты оказания услуги --
                 DATE_FROM, DATE_TO
              FROM (
                SELECT I.SUBSERVICE_ID, I.CHARGE_TYPE, I.TAX_INCL, 
                   SUM(BILL_TOTAL) AMOUNT, 
                   MIN(GREATEST(TRUNC(I.DATE_FROM,'mm'), TRUNC(O.DATE_FROM))) DATE_FROM,
                   MAX(LEAST((ADD_MONTHS(TRUNC(I.DATE_TO,'mm'),1)-1/86400), O.DATE_TO)) DATE_TO
                FROM ITEM_T I, ORDER_T O
                 WHERE I.BILL_ID = p_bill_id
                   AND I.REP_PERIOD_ID = p_rep_period_id
                   AND I.ORDER_ID = O.ORDER_ID
                   AND I.SERVICE_ID = p_service_id
                GROUP BY I.SUBSERVICE_ID, I.CHARGE_TYPE, I.TAX_INCL
            )
        )
        GROUP BY SUBSERVICE_ID, CHARGE_TYPE
        ORDER BY SUBSERVICE_ID, CHARGE_TYPE DESC
    )
    LOOP
        -- вычисляем id строки счета-фактуры от id строки счета
        v_inv_item_id := PK02_POID.Next_invoice_item_id;
        
        -- раздельно по компонентам услуги
        INSERT INTO INVOICE_ITEM_T (
           BILL_ID, REP_PERIOD_ID,
           INV_ITEM_ID, INV_ITEM_NO, SERVICE_ID, INV_ITEM_NAME, 
           VAT,         -- ставка НДС в процентах
           TOTAL,       -- сумма начислений с налогом
           GROSS,       -- сумма начислений без налога
           TAX,         -- сумма налога
           DATE_FROM, DATE_TO
        )
        SELECT 
             p_bill_id, p_rep_period_id, 
             v_inv_item_id, p_inv_item_no, p_service_id, 
             CASE
               WHEN c_item.charge_type = 'DIS' THEN SS.SUBSERVICE||', Скидка 20%'
               ELSE SS.SUBSERVICE 
             END INV_ITEM_NAME, 
             p_vat,
             c_item.SUM_TOTAL, c_item.SUM_GROSS, c_item.SUM_TAX, 
             c_item.DATE_FROM, c_item.DATE_TO
          FROM SUBSERVICE_T SS
         WHERE SS.SUBSERVICE_ID = c_item.SUBSERVICE_ID;
        --
        -- проставляем признак вхождения в счет-фактуру, строкам счета (item)
        UPDATE ITEM_T 
           SET INV_ITEM_ID   = v_inv_item_id
         WHERE BILL_ID       = p_bill_id
           AND REP_PERIOD_ID = p_rep_period_id
           AND SERVICE_ID    = p_service_id
           AND SUBSERVICE_ID = c_item.SUBSERVICE_ID;
         
        -- переходим к следующей позиции в счете
        p_inv_item_no := p_inv_item_no + 1;
        --

    END LOOP;
   
EXCEPTION
    WHEN OTHERS THEN
        Pk01_Syslog.raise_Exception('ERROR. Bill_id='||p_bill_id
                                  ||', service_id='||p_service_id, c_PkgName||'.'||v_prcName );
END;


-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Расчитать счет-фактуру
--   - положительное - кол-во строк в счете-фактуры
--   - при ошибке выставляет исключение
FUNCTION Calc_invoice (
               p_bill_id       IN INTEGER,   -- ID позиции счета
               p_rep_period_id IN INTEGER    -- ID отчетного периода счета
           ) RETURN NUMBER
IS
    v_prcName       CONSTANT VARCHAR2(30) := 'Calc_invoice';
    v_count         INTEGER := 0; -- в нулевой строке баланс за предыдущий период
    -- - - - - - - - - - -- 
    v_account_id    INTEGER;
    v_contract_id   INTEGER;
    v_customer_id   INTEGER;
    v_vat           NUMBER;
    v_inv_item_name INVOICE_ITEM_T.INV_ITEM_NAME%TYPE;
    v_bill_type     CHAR(1);
    v_date_from     DATE;
    v_service_id    INTEGER;
    v_inv_rule_id   INTEGER;
    v_retcode       INTEGER;
    -- - - - - - - - - - --
    c_items         SYS_REFCURSOR;
BEGIN
    -- получаем налоговую ставку л/с действующую в указанном биллинговом периоде
    -- используем запись профиля, указанную в счете
    SELECT B.ACCOUNT_ID, B.CONTRACT_ID, AP.CUSTOMER_ID, 
           B.VAT, B.BILL_TYPE, B.INVOICE_RULE_ID
      INTO v_account_id, v_contract_id, v_customer_id, 
           v_vat, v_bill_type, v_inv_rule_id
      FROM BILL_T B, ACCOUNT_PROFILE_T AP
     WHERE B.BILL_ID        = p_bill_id
       AND B.REP_PERIOD_ID  = p_rep_period_id
       AND B.PROFILE_ID     = AP.PROFILE_ID;

    -- формируем выборку в зависимости от правила формирования строк, указанного в счете
    IF v_inv_rule_id IN ( Pk00_Const.c_INVOICE_RULE_EXT, 
                          Pk00_Const.c_INVOICE_RULE_SUB_EXT )
    THEN
        -- invoice_item-ы группируются по периодам item-ов
        OPEN c_items FOR
          SELECT I.SERVICE_ID, O.SERVICE_ALIAS, 
                 TRUNC(I.DATE_FROM,'mm') DATE_FROM 
            FROM ITEM_T I, ORDER_T O
           WHERE BILL_ID = p_bill_id
             AND I.REP_PERIOD_ID = p_rep_period_id
             AND I.ORDER_ID = O.ORDER_ID
             GROUP BY I.SERVICE_ID, O.SERVICE_ALIAS, TRUNC(I.DATE_FROM,'mm')
             ORDER BY 1,2
        ;
    ELSE 
         -- все item-ы группируются в один invoice_item, без учета периода 
         -- Pk00_Const.c_INVOICE_RULE_STD     -- 7701;
         -- Pk00_Const.c_INVOICE_RULE_BIL     -- 7702;
         -- Pk00_Const.c_INVOICE_RULE_SUB_STD -- 7704;
         -- Pk00_Const.c_INVOICE_RULE_SUB_BIL -- 7705;
         -- 7707 THEN  -- РЖД ЦСС, договор "MS107643/ЦССА/353H11"
        OPEN c_items FOR
          SELECT I.SERVICE_ID, O.SERVICE_ALIAS,
                 NULL DATE_FROM -- период неопределен, все item-ы группируются в один invoice_item
            FROM ITEM_T I, ORDER_T O
           WHERE I.BILL_ID = p_bill_id
             AND I.REP_PERIOD_ID = p_rep_period_id
             AND I.ORDER_ID = O.ORDER_ID
             GROUP BY I.SERVICE_ID, O.SERVICE_ALIAS
             ORDER BY 1
        ;
    END IF;

    -- формируем строки счета фактуры для всех видов услуг    
    -- нумерация с единицы
    v_count := 1;
    --
    LOOP
        FETCH c_items INTO v_service_id, v_inv_item_name, v_date_from;
        EXIT WHEN c_items%NOTFOUND;

        -- получаем имя позиции счета фактуры
        IF v_inv_item_name IS NULL THEN
            v_inv_item_name := Get_item_name (
                  p_service_id  => v_service_id,
                  p_account_id  => v_account_id,
                  p_contract_id => v_contract_id,
                  p_customer_id => v_customer_id
               );
        END IF;

        -- расчет позиций счета фактуры по указанным в BILL_T.INVOICE_RULE_ID правилам
        IF    v_inv_rule_id = Pk00_Const.c_INVOICE_RULE_BIL THEN     -- 7702;
            Calc_inv_item_ext (
                p_inv_item_no   => v_count,        -- номер строки в счете фактуре
                p_bill_id       => p_bill_id,      -- ID позиции счета
                p_rep_period_id => p_rep_period_id,-- ID отчетного периода счета
                p_service_id    => v_service_id,   -- ID услуги
                p_inv_item_name => v_inv_item_name,-- имя строки в счете фактуре
                p_vat           => v_vat,          -- ставка налога в процентах
                p_date_from     => v_date_from     -- все в биллинговый период
            );
        ELSIF v_inv_rule_id = Pk00_Const.c_INVOICE_RULE_EXT THEN
            Calc_inv_item_ext (
                p_inv_item_no   => v_count,        -- номер строки в счете фактуре
                p_bill_id       => p_bill_id,      -- ID позиции счета
                p_rep_period_id => p_rep_period_id,-- ID отчетного периода счета
                p_service_id    => v_service_id,   -- ID услуги
                p_inv_item_name => v_inv_item_name,-- имя строки в счете фактуре
                p_vat           => v_vat,          -- ставка налога в процентах
                p_date_from     => v_date_from     -- дата периода
            );
        ELSIF v_inv_rule_id = Pk00_Const.c_INVOICE_RULE_SUB_STD THEN -- 7704;
            Calc_inv_item_subsrv_std (
                p_inv_item_no   => v_count,        -- номер строки в счете фактуре
                p_bill_id       => p_bill_id,      -- ID позиции счета
                p_rep_period_id => p_rep_period_id,-- ID отчетного периода счета
                p_service_id    => v_service_id,   -- ID услуги
                p_vat           => v_vat           -- ставка налога в процентах
             );
        ELSIF v_inv_rule_id = Pk00_Const.c_INVOICE_RULE_SUB_BIL THEN -- 7705;
            Calc_inv_item_subsrv_ext (
                p_inv_item_no   => v_count,        -- номер строки в счете фактуре
                p_bill_id       => p_bill_id,      -- ID позиции счета
                p_rep_period_id => p_rep_period_id,-- ID отчетного периода счета
                p_service_id    => v_service_id,   -- ID услуги
                p_vat           => v_vat,          -- ставка налога в процентах
                p_date_from     => NULL            -- все в биллинговый период
             );
        ELSIF v_inv_rule_id = Pk00_Const.c_INVOICE_RULE_SUB_EXT THEN
            Calc_inv_item_subsrv_ext (
                p_inv_item_no   => v_count,        -- номер строки в счете фактуре
                p_bill_id       => p_bill_id,      -- ID позиции счета
                p_rep_period_id => p_rep_period_id,-- ID отчетного периода счета
                p_service_id    => v_service_id,   -- ID услуги
                p_vat           => v_vat,          -- ставка налога в процентах
                p_date_from     => v_date_from     -- дата периода
             );
        --ELSIF v_inv_rule_id = Pk00_Const.c_INVOICE_RULE_STD 
        --  AND v_service_id = Pk00_Const.c_SERVICE_OP_LOCAL THEN
        --    -- это пока заглушка для межоператорских услуг
        --    Calc_inv_item_subsrv_std (
        --        p_inv_item_no   => v_count,        -- номер строки в счете фактуре
        --        p_bill_id       => p_bill_id,      -- ID позиции счета
        --        p_rep_period_id => p_rep_period_id,-- ID отчетного периода счета
        --        p_service_id    => v_service_id,   -- ID услуги
        --        p_vat           => v_vat           -- ставка налога в процентах
        --     );
        ELSIF v_inv_rule_id = 7707 THEN -- 7707 ЦСС РЖД;
            Calc_inv_item_rzd (
                p_inv_item_no   => v_count,        -- номер строки в счете фактуре
                p_bill_id       => p_bill_id,      -- ID позиции счета
                p_rep_period_id => p_rep_period_id,-- ID отчетного периода счета
                p_service_id    => v_service_id,   -- ID услуги
                p_inv_item_name => v_inv_item_name,-- имя строки в счете фактуре
                p_vat           => v_vat           -- ставка налога в процентах
             );
        ELSE               -- Pk00_Const.c_INVOICE_RULE_STD          -- 7701;
            Calc_inv_item_std (
                p_inv_item_no   => v_count,        -- номер строки в счете фактуре
                p_bill_id       => p_bill_id,      -- ID позиции счета
                p_rep_period_id => p_rep_period_id,-- ID отчетного периода счета
                p_service_id    => v_service_id,   -- ID услуги
                p_inv_item_name => v_inv_item_name,-- имя строки в счете фактуре
                p_vat           => v_vat,          -- ставка налога в процентах
                p_bill_type     => v_bill_type
            );
        END IF;

    END LOOP;
    
    -- закрываем курсор
    CLOSE c_items;
    --
    RETURN v_count;
EXCEPTION
    WHEN OTHERS THEN
        v_retcode := Pk01_SysLog.Fn_write_Error('ERROR. Bill_id='||p_bill_id, c_PkgName||'.'||v_prcName);
        IF c_items%ISOPEN THEN 
            CLOSE c_items;
        END IF;
        RAISE_APPLICATION_ERROR(Pk01_SysLog.n_APP_EXCEPTION, 'msg_id='||v_retcode||':'||c_PkgName||'.'||v_prcName);  
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- найти все позиции указанного счета-фактуры
--   - положительное - кол-во выбранных записей
--   - при ошибке выставляет исключение
FUNCTION Invoice_items_list( 
               p_recordset OUT t_refc, 
               p_bill_id       IN INTEGER,   -- ID позиции счета
               p_rep_period_id IN INTEGER    -- ID отчетного периода счета
           ) RETURN INTEGER
IS
    v_prcName    CONSTANT VARCHAR2(30) := 'Invoice_items_list';
    v_retcode    INTEGER;
BEGIN
    -- вычисляем кол-во записей
    SELECT COUNT(*) INTO v_retcode
      FROM INVOICE_ITEM_T
     WHERE BILL_ID = p_bill_id;
    -- возвращаем курсор
    OPEN p_recordset FOR
         SELECT BILL_ID, REP_PERIOD_ID,
                INV_ITEM_ID, INV_ITEM_NO, SERVICE_ID, 
                VAT, TAX, GROSS, TOTAL,
                INV_ITEM_NAME, DATE_FROM, DATE_TO
           FROM INVOICE_ITEM_T
          WHERE BILL_ID = p_bill_id
            AND REP_PERIOD_ID = p_rep_period_id
          ORDER BY INV_ITEM_NO;
    RETURN v_retcode;
EXCEPTION
    WHEN OTHERS THEN
        v_retcode := Pk01_SysLog.Fn_write_Error('ERROR', c_PkgName||'.'||v_prcName);
        IF p_recordset%ISOPEN THEN 
            CLOSE p_recordset;
        END IF;
        RAISE_APPLICATION_ERROR(Pk01_SysLog.n_APP_EXCEPTION, 'msg_id='||v_retcode||':'||c_PkgName||'.'||v_prcName);
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Список правил формирования строк счтов-фактур
PROCEDURE Invoice_rules_list( 
               p_recordset IN OUT SYS_REFCURSOR
           )
IS
    v_prcName    CONSTANT VARCHAR2(30) := 'Invoice_rules_list';
    v_retcode    INTEGER;
BEGIN
    -- возвращаем курсор
    OPEN p_recordset FOR
        SELECT KEY_ID INVOICE_RULE_ID, KEY INVOICE_RULE_KEY, NAME INVOICE_RULE, NOTES 
          FROM DICTIONARY_T
         WHERE PARENT_ID = Pk00_Const.k_DICT_INV_RULE
         ORDER BY 1;
EXCEPTION
    WHEN OTHERS THEN
        v_retcode := Pk01_SysLog.Fn_write_Error('ERROR', c_PkgName||'.'||v_prcName);
        IF p_recordset%ISOPEN THEN 
            CLOSE p_recordset;
        END IF;
        RAISE_APPLICATION_ERROR(Pk01_SysLog.n_APP_EXCEPTION, 'msg_id='||v_retcode||':'||c_PkgName||'.'||v_prcName);
END;

-- Удалить все позиции указанного счета-фактуры
--   - положительное - кол-во удаленных записей
--   - при ошибке выставляет исключение
FUNCTION Delete_invoice_items (
               p_bill_id       IN INTEGER,   -- ID позиции счета
               p_rep_period_id IN INTEGER    -- ID отчетного периода счета
           ) RETURN INTEGER
IS
    v_prcName     CONSTANT VARCHAR2(30) := 'Delete_invoice_items';
BEGIN
    -- удаляем причнак вхождения позиций счета в счет-фактуру
    -- если есть записи в ITEM_T, то при удалении
    -- сработает constraint ITEM_T_INVOICE_ITEM_T_FK
    UPDATE ITEM_T SET INV_ITEM_ID = NULL
     WHERE BILL_ID = p_bill_id
       AND REP_PERIOD_ID = p_rep_period_id;
    -- удаляем все позиции указанного счета-фактуры,
    DELETE 
      FROM INVOICE_ITEM_T
     WHERE BILL_ID = p_bill_id
       AND REP_PERIOD_ID = p_rep_period_id;
    -- возвращает кол-во удаленных записей
    RETURN SQL%ROWCOUNT;
EXCEPTION
    WHEN OTHERS THEN
        RETURN(-Pk01_SysLog.Fn_write_Error('ERROR', c_PkgName||'.'||v_prcName));
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Редактирование позции счет-фактуры
PROCEDURE Edit_invoice_item_name ( 
          p_bill_id      IN    INTEGER,
          p_period_id    IN    INTEGER,
          p_invoice_id   IN    INTEGER,
          p_name         IN    VARCHAR2
)
IS
    v_prcName    CONSTANT VARCHAR2(30) := 'Edit_invoice_item_name';
    v_retcode    INTEGER;
BEGIN
    UPDATE INVOICE_ITEM_T
       SET INV_ITEM_NAME = p_name
    WHERE 
         BILL_ID = p_bill_id 
       AND REP_PERIOD_ID = p_period_id
       AND INV_ITEM_ID = p_invoice_id;     
EXCEPTION
    WHEN OTHERS THEN
        v_retcode := Pk01_SysLog.Fn_write_Error('ERROR', c_PkgName||'.'||v_prcName);
        RAISE_APPLICATION_ERROR(Pk01_SysLog.n_APP_EXCEPTION, 'msg_id='||v_retcode||':'||c_PkgName||'.'||v_prcName);
END;

END PK09_INVOICE;
/
