CREATE OR REPLACE PACKAGE PK36_BILLING_FIXRATE_OLD
IS
    -- ==============================================================================
    c_PkgName   constant varchar2(30) := 'PK36_BILLING_FIXRATE_OLD';
    -- ==============================================================================
    c_RET_OK    constant integer := 0;
    c_RET_ER		constant integer :=-1;
    
    --=============================================================================--
    --                РАСЧЕТ НАЧИСЛЕНИЙ ПО ПРОСТЫМ ТАРИФАМ                         --
    --=============================================================================--
    -- Создание периодических счетов для клиентов имеющих
    -- абонплату или доплату до минимальной стоимости
    -- в биллинговом периоде p_period_id
    PROCEDURE Make_bills_for_fixrates(p_period_id IN INTEGER);

    --  Расчет абонплаты (subscriber fee)
    PROCEDURE Charge_ABP( p_task_id IN INTEGER );

    --  Расчет абонплаты (subscriber fee) по тарифам укзанным 
    -- индивидуально для каждого месяца (MONTH_TARIFF_T),
    -- такой тариф иногда требуют бюджетные организации, 
    -- заключающие договор на один год, затем тендер и новый договор
    -- для биллингового периода p_period_id
    PROCEDURE Charge_ABP_by_month_tariff( p_task_id IN INTEGER );

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    --  Заполнить поля необходимые для получения детализации по абонплате
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    PROCEDURE Put_ABP_detail( p_task_id IN INTEGER );

    --  Расчет доплаты до мимнимальной суммы КОМПОМЕНТА УСЛУГИ ЗАКАЗА
    PROCEDURE Subservice_charge_MIN( p_task_id IN INTEGER );

    --  Расчет доплаты до мимнимальной суммы ЗАКАЗА
    PROCEDURE Order_charge_MIN( p_task_id IN INTEGER );
    
    --  Расчет доплаты до мимнимальной суммы Лицевого счета
    PROCEDURE Account_charge_MIN( p_task_id IN INTEGER );
    
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Расформирование фиксированных начислений,
    -- за исключением тех что сформировал тарификатор трафика
    PROCEDURE Rollback_fixrates( p_task_id IN INTEGER );
    
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Начисление абонентской платы и доплаты до минимальной суммы
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    PROCEDURE Charge_fixrates( p_task_id IN INTEGER );
    
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Нестандартные правила начисления АБП и Доплаты до минималки
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    PROCEDURE Charge_non_std_fixrates( p_bill_period_id IN INTEGER );
       
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    --     В С П О М О Г А Т Е Л Ь Н Ы Е   Ф У Н К Ц И И
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Функция конвертации валюты тарифа в рубли
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    FUNCTION Currency_rate(
             p_value       IN NUMBER,
             p_currency_id IN INTEGER, 
             p_date_rate   IN DATE
      ) RETURN NUMBER;
    
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Функция вычисления понижающего коэффициента к ежемесячному платежу, 
    -- по кол-ву дней, когда услуга реально предоставлялась
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    FUNCTION Period_ratio(
             p_period_id     IN INTEGER,
             p_order_body_id IN INTEGER
      ) RETURN NUMBER;
    
END PK36_BILLING_FIXRATE_OLD;
/
CREATE OR REPLACE PACKAGE BODY PK36_BILLING_FIXRATE_OLD
IS

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Создание периодических счетов для клиентов имеющих
-- абонплату или доплату до минимальной стоимости
-- в биллинговом периоде p_period_id
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
PROCEDURE Make_bills_for_fixrates(p_period_id IN INTEGER)
IS
    v_prcName       CONSTANT VARCHAR2(30) := 'Make_bills_for_fixrates';
    v_period_from   DATE;
    v_period_to     DATE;
    v_bill_id       INTEGER;
    v_count         INTEGER;
BEGIN
    Pk01_Syslog.Write_msg('Start, period_id = '||p_period_id, c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --
    v_period_from := Pk04_Period.Period_from(p_period_id);
    v_period_to   := Pk04_Period.Period_to(p_period_id);
    --
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Создаем периодические счета в биллинговом периоде для л/с где их нет
    v_count := 0;
    --
    FOR rb IN (
      SELECT DISTINCT A.ACCOUNT_ID 
        FROM ORDER_BODY_T OB, ORDER_T O, ACCOUNT_T A
       WHERE OB.CHARGE_TYPE IN (PK00_CONST.c_CHARGE_TYPE_MIN, PK00_CONST.c_CHARGE_TYPE_REC)
         AND OB.ORDER_ID = O.ORDER_ID 
         AND A.ACCOUNT_ID = O.ACCOUNT_ID
         AND A.STATUS = Pk00_Const.c_ACC_STATUS_BILL
         AND O.DATE_FROM <= v_period_to
         AND ( O.DATE_TO IS NULL OR v_period_from <= O.DATE_TO) 
         AND OB.DATE_FROM <= v_period_to
         AND ( OB.DATE_TO IS NULL OR v_period_from <=  OB.DATE_TO)
         AND NOT EXISTS (
            SELECT * FROM BILL_T B
             WHERE B.REP_PERIOD_ID = p_period_id
               AND B.ACCOUNT_ID    = A.ACCOUNT_ID
               AND B.BILL_TYPE     = PK00_CONST.c_BILL_TYPE_REC
         )
    )LOOP
      v_bill_id := Pk07_BIll.Next_recuring_bill (
               p_account_id    => rb.account_id, -- ID лицевого счета
               p_rep_period_id => p_period_id    -- ID расчетного периода YYYYMM
           );
      v_count := v_count + 1;
    END LOOP;
    Pk01_Syslog.Write_msg('Bill_t: '||v_count||' rows created ', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    Pk01_Syslog.Write_msg('Stop.', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
EXCEPTION WHEN OTHERS THEN
    Pk01_Syslog.raise_Exception('ERROR', c_PkgName||'.'||v_prcName );
END;


-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
--  Расчет абонплаты (subscriber fee)
-- для биллингового периода p_period_id
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
PROCEDURE Charge_ABP( p_task_id IN INTEGER )
IS
    v_prcName       CONSTANT VARCHAR2(30) := 'Charge_ABP';
    v_count         INTEGER;
BEGIN
    Pk01_Syslog.Write_msg('Start, task_id = '||p_task_id, c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Создаем позиции начислений на абонплату для счетов биллингового периода
    --
    INSERT INTO ITEM_T I(
       BILL_ID, REP_PERIOD_ID, ITEM_ID, ORDER_ID, SERVICE_ID, SUBSERVICE_ID, 
       CHARGE_TYPE, ITEM_TOTAL, DATE_FROM, DATE_TO, TAX_INCL, ITEM_TYPE,
       ITEM_STATUS, ORDER_BODY_ID
    )
    WITH ORD AS (   -- заказы, имющие компоменту услуги - АБОНПЛАТА
        SELECT  ACCOUNT_ID, BILL_ID, REP_PERIOD_ID,
                ORDER_ID, ORDER_BODY_ID, QUANTITY, VALUE, TAX_INCL, 
                CHARGE_TYPE, SERVICE_ID, SUBSERVICE_ID,
                DATE_FROM, DATE_TO,
                ROUND(DATE_TO-DATE_FROM) ORD_DAYS,
                MON_DAYS
          FROM (
            -- -------------------------------------------------------------------- --
            SELECT Q.ACCOUNT_ID, Q.BILL_ID, Q.REP_PERIOD_ID,
                   OB.ORDER_ID, OB.ORDER_BODY_ID, 
                   OB.QUANTITY, 
                   CASE
                     WHEN OB.CURRENCY_ID = Pk00_Const.c_CURRENCY_YE_FIX THEN (OB.RATE_VALUE * 28.6)
                     ELSE OB.RATE_VALUE
                   END VALUE,
                   OB.TAX_INCL, 
                   OB.CHARGE_TYPE, O.SERVICE_ID, OB.SUBSERVICE_ID,
                   TRUNC(
                     CASE
                      WHEN GREATEST(O.DATE_FROM, OB.DATE_FROM) <= P.PERIOD_FROM  
                      THEN P.PERIOD_FROM ELSE GREATEST(O.DATE_FROM, OB.DATE_FROM) 
                     END 
                   ) DATE_FROM,
                   TRUNC(
                     CASE
                      WHEN LEAST(NVL(O.DATE_TO,P.PERIOD_TO), NVL(OB.DATE_TO,P.PERIOD_TO)) >= P.PERIOD_TO  
                      THEN P.PERIOD_TO  ELSE LEAST(NVL(O.DATE_TO,P.PERIOD_TO), NVL(OB.DATE_TO,P.PERIOD_TO))
                     END 
                   ) + 86399/86400 DATE_TO,
                   ROUND(P.PERIOD_TO - P.PERIOD_FROM) MON_DAYS,
                   Q.TASK_ID
              FROM ORDER_BODY_T OB, ORDER_T O, BILLING_QUEUE_T Q, PERIOD_T P
             WHERE OB.CHARGE_TYPE       = Pk00_Const.c_CHARGE_TYPE_REC
               AND OB.RATE_RULE_ID IN  (  Pk00_Const.c_RATE_RULE_ABP_STD,  -- 2402
                                          Pk00_Const.c_RATE_RULE_ABP_FREE_MIN ) -- 2403
               AND O.ORDER_ID           = OB.ORDER_ID
               AND P.PERIOD_ID          = NVL(Q.DATA_PERIOD_ID, Q.REP_PERIOD_ID) 
               AND Q.ACCOUNT_ID         = O.ACCOUNT_ID               
               AND OB.DATE_FROM        <= P.PERIOD_TO
               AND (P.PERIOD_FROM      <= OB.DATE_TO OR OB.DATE_TO IS NULL)
               AND O.DATE_FROM         <= P.PERIOD_TO
               AND (P.PERIOD_FROM      <= O.DATE_TO OR O.DATE_TO IS NULL)
               AND Q.TASK_ID            = p_task_id
               AND OB.RATE_VALUE IS NOT NULL
               AND OB.QUANTITY   IS NOT NULL
            -- -------------------------------------------------------------------- --
            )
    ), LCK AS (    -- блокировки, биллингового периода
        SELECT BILL_ID, REP_PERIOD_ID,
               ORDER_ID, ROUND(SUM(LOCK_DAYS)) LCK_DAYS
          FROM (
            -- -------------------------------------------------------------------- --
            SELECT Q.BILL_ID, Q.REP_PERIOD_ID, L.ORDER_ID, 
                   CASE 
                    -- заблокирован весь месяц:  DATE_FROM---[-------]---DATE_TO
                    WHEN L.DATE_FROM <= P.PERIOD_FROM 
                     AND (P.PERIOD_TO <= L.DATE_TO OR L.DATE_TO IS NULL) 
                    THEN P.PERIOD_TO - P.PERIOD_FROM
                    -- заблокирован внутри месяца: [--DATE_FROM-----DATE_TO--]
                    WHEN P.PERIOD_FROM < L.DATE_FROM 
                     AND L.DATE_TO < P.PERIOD_TO 
                    THEN L.DATE_TO - L.DATE_FROM
                    -- заблокирован в предыдущем периоде, открыт в текущем: ---DATE_FROM-- [---DATE_TO---]
                    WHEN L.DATE_FROM <= P.PERIOD_FROM 
                     AND L.DATE_TO < P.PERIOD_TO 
                    THEN L.DATE_TO - P.PERIOD_FROM
                    -- заблокирован в текущем периоде, и остается до конца периода:---[--DATE_FROM--]---DATE_TO---  
                    WHEN P.PERIOD_FROM < L.DATE_FROM  
                     AND (P.PERIOD_TO <= L.DATE_TO OR L.DATE_TO IS NULL)
                    THEN P.PERIOD_TO - L.DATE_FROM
                    -- возможем некорректный ввод
                    ELSE 0
                   END LOCK_DAYS
              FROM ORDER_LOCK_T L, ORDER_T O, BILLING_QUEUE_T Q, PERIOD_T P
            WHERE L.DATE_FROM    <= P.PERIOD_TO                     -- только блокировки 
              AND (L.DATE_TO IS NULL OR P.PERIOD_FROM <= L.DATE_TO) -- действовавшие в периоде
              AND O.ORDER_ID      = L.ORDER_ID
              AND Q.ACCOUNT_ID    = O.ACCOUNT_ID
              AND P.PERIOD_ID     = NVL(Q.DATA_PERIOD_ID, Q.REP_PERIOD_ID)
              AND Q.TASK_ID       = p_task_id
            -- -------------------------------------------------------------------- --
        )
        GROUP BY BILL_ID, REP_PERIOD_ID, ORDER_ID
    ), ABP AS (
        SELECT ORD.ACCOUNT_ID, ORD.BILL_ID, ORD.REP_PERIOD_ID,
               ORD.ORDER_ID, ORD.ORDER_BODY_ID, 
               ORD.QUANTITY, ORD.VALUE, ORD.TAX_INCL, 
               ORD.CHARGE_TYPE, ORD.SERVICE_ID, ORD.SUBSERVICE_ID, 
               ORD.DATE_FROM, ORD.DATE_TO,
               ORD.ORD_DAYS, ORD.MON_DAYS, NVL(LCK.LCK_DAYS,0) LCK_DAYS,
               (ORD.ORD_DAYS - NVL(LCK.LCK_DAYS,0))/MON_DAYS K_DAYS
          FROM ORD, LCK
         WHERE ORD.ORDER_ID      = LCK.ORDER_ID(+)
           AND ORD.BILL_ID       = LCK.BILL_ID(+) 
           AND ORD.REP_PERIOD_ID = LCK.REP_PERIOD_ID(+)
    )
    SELECT B.BILL_ID, B.REP_PERIOD_ID, SQ_ITEM_ID.NEXTVAL ITEM_ID,
           ORDER_ID, SERVICE_ID, SUBSERVICE_ID, CHARGE_TYPE,  
           ROUND((K_DAYS * QUANTITY * VALUE),2) ITEM_TOTAL,
           DATE_FROM, DATE_TO, TAX_INCL, 
           PK00_CONST.c_ITEM_TYPE_BILL,
           Pk00_Const.c_ITEM_STATE_OPEN,
           ABP.ORDER_BODY_ID
      FROM ABP, BILL_T B
     WHERE ABP.ACCOUNT_ID    = B.ACCOUNT_ID
       AND ABP.REP_PERIOD_ID = B.REP_PERIOD_ID
       AND ABP.BILL_ID       = B.BILL_ID
       AND B.BILL_TYPE     IN (Pk00_Const.c_BILL_TYPE_REC, 
                               Pk00_Const.c_BILL_TYPE_DBT, 
                               Pk00_Const.c_BILL_TYPE_OLD)
       AND K_DAYS > 0
    ;
    v_count := SQL%ROWCOUNT;
    Pk01_Syslog.Write_msg('Item_t: '||v_count||' rows created ', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    Pk01_Syslog.Write_msg('Stop.', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
EXCEPTION WHEN OTHERS THEN
    Pk01_Syslog.raise_Exception('ERROR', c_PkgName||'.'||v_prcName );
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
--  Расчет абонплаты (subscriber fee) по тарифам укзанным 
-- индивидуально для каждого месяца (MONTH_TARIFF_T),
-- такой тариф иногда требуют бюджетные организации, 
-- заключающие договор на один год, затем тендер и новый договор
-- для биллингового периода p_period_id
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
PROCEDURE Charge_ABP_by_month_tariff(p_task_id IN INTEGER )
IS
    v_prcName       CONSTANT VARCHAR2(30) := 'Charge_ABP_by_month_tariff';
    v_count         INTEGER;
BEGIN
    Pk01_Syslog.Write_msg('Start, task_id = '||p_task_id, c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Создаем позиции начислений на абонплату для счетов биллингового периода
    --
    INSERT INTO ITEM_T I(
       BILL_ID, REP_PERIOD_ID, ITEM_ID, ORDER_ID, SERVICE_ID, SUBSERVICE_ID, 
       CHARGE_TYPE, ITEM_TOTAL, DATE_FROM, DATE_TO, TAX_INCL, ITEM_TYPE,
       ITEM_STATUS, ORDER_BODY_ID
    )
    WITH ORD AS (   -- заказы, имющие компоменту услуги - АБОНПЛАТА
        SELECT  ACCOUNT_ID, BILL_ID, REP_PERIOD_ID,
                ORDER_ID, ORDER_BODY_ID, QUANTITY, VALUE, TAX_INCL, 
                CHARGE_TYPE, SERVICE_ID, SUBSERVICE_ID,
                DATE_FROM, DATE_TO,
                ROUND(DATE_TO-DATE_FROM) ORD_DAYS,
                MON_DAYS
          FROM (      
            SELECT Q.ACCOUNT_ID, Q.BILL_ID, Q.REP_PERIOD_ID,
                   OB.ORDER_ID, OB.ORDER_BODY_ID, 
                   OB.QUANTITY, 
                   CASE
                     WHEN R.CURRENCY_ID = Pk00_Const.c_CURRENCY_YE_FIX THEN (T.PRICE * 28.6)
                     ELSE T.PRICE
                   END VALUE,
                   R.TAX_INCL, 
                   OB.CHARGE_TYPE, O.SERVICE_ID, OB.SUBSERVICE_ID,
                   CASE
                    WHEN GREATEST(O.DATE_FROM, OB.DATE_FROM) <= P.PERIOD_FROM  
                    THEN P.PERIOD_FROM ELSE GREATEST(O.DATE_FROM, OB.DATE_FROM) 
                   END DATE_FROM,
                   CASE
                    WHEN LEAST(NVL(O.DATE_TO,P.PERIOD_TO), NVL(OB.DATE_TO,P.PERIOD_TO)) >= P.PERIOD_TO  
                    THEN P.PERIOD_TO  ELSE LEAST(NVL(O.DATE_TO,P.PERIOD_TO), NVL(OB.DATE_TO,P.PERIOD_TO))
                   END DATE_TO,
                   ROUND(P.PERIOD_TO - P.PERIOD_FROM) MON_DAYS
              FROM ORDER_BODY_T OB, ORDER_T O, 
                   BILLING_QUEUE_T Q, PERIOD_T P,
                   RATEPLAN_T R, MONTH_TARIFF_T T
             WHERE OB.CHARGE_TYPE  = Pk00_Const.c_CHARGE_TYPE_REC
               AND OB.RATE_RULE_ID = Pk00_Const.c_RATE_RULE_ABP_MON
               AND OB.RATEPLAN_ID  = R.RATEPLAN_ID
               AND R.RATESYSTEM_ID = Pk00_Const.с_RATESYS_MON_TRF_ID
               AND R.RATEPLAN_ID   = T.RATEPLAN_ID
               AND T.PERIOD_ID     = NVL(Q.DATA_PERIOD_ID, Q.REP_PERIOD_ID)
               AND O.ORDER_ID      = OB.ORDER_ID
               AND P.PERIOD_ID     = NVL(Q.DATA_PERIOD_ID, Q.REP_PERIOD_ID)
               AND Q.ACCOUNT_ID    = O.ACCOUNT_ID               
               AND OB.DATE_FROM   <= P.PERIOD_TO
               AND (P.PERIOD_FROM <= OB.DATE_TO OR OB.DATE_TO IS NULL)
               AND O.DATE_FROM    <= P.PERIOD_TO
               AND (P.PERIOD_FROM <= O.DATE_TO OR O.DATE_TO IS NULL)
               AND Q.TASK_ID       = p_task_id
            )
    ), LCK AS (    -- блокировки, биллингового периода
        SELECT BILL_ID, REP_PERIOD_ID,
               ORDER_ID, ROUND(SUM(LOCK_DAYS)) LCK_DAYS
          FROM (
            -- -------------------------------------------------------------------- --
            SELECT Q.BILL_ID, Q.REP_PERIOD_ID, L.ORDER_ID, 
                   CASE 
                    -- заблокирован весь месяц:  DATE_FROM---[-------]---DATE_TO
                    WHEN L.DATE_FROM <= P.PERIOD_FROM 
                     AND (P.PERIOD_TO <= L.DATE_TO OR L.DATE_TO IS NULL) 
                    THEN P.PERIOD_TO - P.PERIOD_FROM
                    -- заблокирован внутри месяца: [--DATE_FROM-----DATE_TO--]
                    WHEN P.PERIOD_FROM < L.DATE_FROM 
                     AND L.DATE_TO < P.PERIOD_TO 
                    THEN L.DATE_TO - L.DATE_FROM
                    -- заблокирован в предыдущем периоде, открыт в текущем: ---DATE_FROM-- [---DATE_TO---]
                    WHEN L.DATE_FROM <= P.PERIOD_FROM 
                     AND L.DATE_TO < P.PERIOD_TO 
                    THEN L.DATE_TO - P.PERIOD_FROM
                    -- заблокирован в текущем периоде, и остается до конца периода:---[--DATE_FROM--]---DATE_TO---  
                    WHEN P.PERIOD_FROM < L.DATE_FROM  
                     AND (P.PERIOD_TO <= L.DATE_TO OR L.DATE_TO IS NULL)
                    THEN P.PERIOD_TO - L.DATE_FROM
                    -- возможем некорректный ввод
                    ELSE 0
                   END LOCK_DAYS
              FROM ORDER_LOCK_T L, ORDER_T O, BILLING_QUEUE_T Q, PERIOD_T P
            WHERE L.DATE_FROM    <= P.PERIOD_TO                     -- только блокировки 
              AND (L.DATE_TO IS NULL OR P.PERIOD_FROM <= L.DATE_TO) -- действовавшие в периоде
              AND O.ORDER_ID      = L.ORDER_ID
              AND Q.ACCOUNT_ID    = O.ACCOUNT_ID
              AND P.PERIOD_ID     = NVL(Q.DATA_PERIOD_ID, Q.REP_PERIOD_ID)
              AND Q.TASK_ID       = p_task_id
            -- -------------------------------------------------------------------- --
        )
        GROUP BY BILL_ID, REP_PERIOD_ID, ORDER_ID
    ), ABP AS (
        SELECT ORD.ACCOUNT_ID, ORD.BILL_ID, ORD.REP_PERIOD_ID,
               ORD.ORDER_ID, ORD.ORDER_BODY_ID, 
               ORD.QUANTITY, ORD.VALUE, ORD.TAX_INCL, 
               ORD.CHARGE_TYPE, ORD.SERVICE_ID, ORD.SUBSERVICE_ID, 
               ORD.DATE_FROM, ORD.DATE_TO,
               ORD.ORD_DAYS, ORD.MON_DAYS, NVL(LCK.LCK_DAYS,0) LCK_DAYS,
               CASE
                WHEN ORD.ORD_DAYS < NVL(LCK.LCK_DAYS,0) THEN 0
                ELSE ((ORD.ORD_DAYS - NVL(LCK.LCK_DAYS,0))/MON_DAYS)
               END K_DAYS
          FROM ORD, LCK
         WHERE ORD.ORDER_ID      = LCK.ORDER_ID(+)
           AND ORD.BILL_ID       = LCK.BILL_ID(+) 
           AND ORD.REP_PERIOD_ID = LCK.REP_PERIOD_ID(+)
    )
    SELECT B.BILL_ID, B.REP_PERIOD_ID, SQ_ITEM_ID.NEXTVAL ITEM_ID,
           ORDER_ID, SERVICE_ID, SUBSERVICE_ID, CHARGE_TYPE,  
           -- на текущий момент ITEM для Ю всегда считается без налогов
           -- возможно позже исправлю
           CASE 
             WHEN TAX_INCL = Pk00_Const.c_RATEPLAN_TAX_INCL THEN 
               ROUND((K_DAYS * QUANTITY * VALUE/1.18),2)
             ELSE
               ROUND((K_DAYS * QUANTITY * VALUE),2)
           END ITEM_TOTAL,
           DATE_FROM, DATE_TO, 
           Pk00_Const.c_RATEPLAN_TAX_NOT_INCL, -- начисления для Ю по безналоговому тарифу
           PK00_CONST.c_ITEM_TYPE_BILL,
           Pk00_Const.c_ITEM_STATE_OPEN,
           ABP.ORDER_BODY_ID
      FROM ABP, BILL_T B
     WHERE B.ACCOUNT_ID    = ABP.ACCOUNT_ID 
       AND B.REP_PERIOD_ID = ABP.REP_PERIOD_ID
       AND B.ACCOUNT_ID    = ABP.ACCOUNT_ID
       AND B.BILL_TYPE   IN (Pk00_Const.c_BILL_TYPE_REC, 
                             Pk00_Const.c_BILL_TYPE_DBT, 
                             Pk00_Const.c_BILL_TYPE_OLD)
    ;
    v_count := SQL%ROWCOUNT;
    Pk01_Syslog.Write_msg('Item_t: '||v_count||' rows created ', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    Pk01_Syslog.Write_msg('Stop.', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
EXCEPTION WHEN OTHERS THEN
    Pk01_Syslog.raise_Exception('ERROR', c_PkgName||'.'||v_prcName );
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
--  Заполнить поля необходимые для получения детализации по абонплате
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
PROCEDURE Put_ABP_detail( p_task_id IN INTEGER )    
IS
    v_prcName       CONSTANT VARCHAR2(30) := 'Put_ABP_detail';
    v_count         INTEGER;
BEGIN
    Pk01_Syslog.Write_msg('Start, task_id = '||p_task_id, c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Заполняем поля описания начислений абонплаты для стандартной детализации
    -- 1) Услуга NPL
    -- 2) Услуга IP_ACCESS 
    -- 3) Услуга EPL
    -- 4) Услуга DPL
    -- 5) Услуга LM
    MERGE INTO ITEM_T I
    USING (
        SELECT I.ITEM_ID,
               CASE 
                    WHEN I.SERVICE_ID = Pk00_Const.c_SERVICE_IP_ACCESS -- 104 
                      THEN 'IP port, '||INF.POINT_SRC||', '||INF.SPEED_STR
                    WHEN I.SERVICE_ID IN ( Pk00_Const.c_SERVICE_VPN, Pk00_Const.c_SERVICE_LM) -- 106, 108 
                      THEN INF.POINT_SRC||', '||INF.SPEED_STR
                    ELSE INF.POINT_SRC||DECODE(INF.POINT_DST, NULL, NULL,' - '||INF.POINT_DST)||', '||INF.SPEED_STR
               END STR
          FROM ORDER_INFO_T INF, ITEM_T I, BILLING_QUEUE_T Q
        WHERE I.CHARGE_TYPE   IN ( Pk00_Const.c_CHARGE_TYPE_REC )
          AND INF.ORDER_ID    = I.ORDER_ID
          AND Q.BILL_ID       = I.BILL_ID
          AND Q.REP_PERIOD_ID = I.REP_PERIOD_ID
          AND Q.TASK_ID       = p_task_id
          AND INF.POINT_SRC   IS NOT NULL
    ) INF
    ON (
        I.ITEM_ID = INF.ITEM_ID 
    )
    WHEN MATCHED THEN UPDATE SET I.DESCR = INF.STR;    
    v_count := SQL%ROWCOUNT;
    Pk01_Syslog.Write_msg('Item_t: '||v_count||' rows, set desc ', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    Pk01_Syslog.Write_msg('Stop.', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
EXCEPTION WHEN OTHERS THEN
    Pk01_Syslog.raise_Exception('ERROR', c_PkgName||'.'||v_prcName );
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
--  Расчет доплаты до мимнимальной суммы КОМПОМЕНТА УСЛУГИ ЗАКАЗА
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
PROCEDURE Subservice_charge_MIN( p_task_id IN INTEGER )    
IS
    v_prcName       CONSTANT VARCHAR2(30) := 'Subservice_charge_MIN';
    v_count         INTEGER;
BEGIN
    Pk01_Syslog.Write_msg('Start, task_id = '||p_task_id, c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Создаем позиции начислений доплаты до мимнимальной суммы КОМПОНЕНТА услуги
    --
    INSERT INTO ITEM_T(
        BILL_ID, REP_PERIOD_ID, ITEM_ID, ORDER_ID, SERVICE_ID, SUBSERVICE_ID, 
        CHARGE_TYPE, ITEM_TOTAL, DATE_FROM, DATE_TO, TAX_INCL, ITEM_TYPE,
        ITEM_STATUS, ORDER_BODY_ID
    )
    WITH LCK AS (
        SELECT BILL_ID, REP_PERIOD_ID,
               ORDER_ID, ROUND(SUM(LOCK_DAYS)) LCK_DAYS
          FROM (
            -- -------------------------------------------------------------------- --
            SELECT Q.BILL_ID, Q.REP_PERIOD_ID, L.ORDER_ID, 
                   CASE 
                    -- заблокирован весь месяц:  DATE_FROM---[-------]---DATE_TO
                    WHEN L.DATE_FROM <= P.PERIOD_FROM 
                     AND (P.PERIOD_TO <= L.DATE_TO OR L.DATE_TO IS NULL) 
                    THEN P.PERIOD_TO - P.PERIOD_FROM
                    -- заблокирован внутри месяца: [--DATE_FROM-----DATE_TO--]
                    WHEN P.PERIOD_FROM < L.DATE_FROM 
                     AND L.DATE_TO < P.PERIOD_TO 
                    THEN L.DATE_TO - L.DATE_FROM
                    -- заблокирован в предыдущем периоде, открыт в текущем: ---DATE_FROM-- [---DATE_TO---]
                    WHEN L.DATE_FROM <= P.PERIOD_FROM 
                     AND L.DATE_TO < P.PERIOD_TO 
                    THEN L.DATE_TO - P.PERIOD_FROM
                    -- заблокирован в текущем периоде, и остается до конца периода:---[--DATE_FROM--]---DATE_TO---  
                    WHEN P.PERIOD_FROM < L.DATE_FROM  
                     AND (P.PERIOD_TO <= L.DATE_TO OR L.DATE_TO IS NULL)
                    THEN P.PERIOD_TO - L.DATE_FROM
                    -- возможем некорректный ввод
                    ELSE 0
                   END LOCK_DAYS
              FROM ORDER_LOCK_T L, ORDER_T O, BILLING_QUEUE_T Q, PERIOD_T P
            WHERE L.DATE_FROM    <= P.PERIOD_TO                     -- только блокировки 
              AND (L.DATE_TO IS NULL OR P.PERIOD_FROM <= L.DATE_TO) -- действовавшие в периоде
              AND O.ORDER_ID      = L.ORDER_ID
              AND Q.ACCOUNT_ID    = O.ACCOUNT_ID
              AND P.PERIOD_ID     = NVL(Q.DATA_PERIOD_ID, Q.REP_PERIOD_ID)
              AND Q.TASK_ID       = p_task_id
            -- -------------------------------------------------------------------- --
        )
        GROUP BY BILL_ID, REP_PERIOD_ID, ORDER_ID
    ), MP AS (
        SELECT BILL_ID, REP_PERIOD_ID, ACCOUNT_ID, ORDER_ID, ORDER_BODY_ID,
               SERVICE_ID, SUBSERVICE_ID, CHARGE_TYPE, 
               DATE_FROM, DATE_TO, TAX_INCL, MIN_VALUE, VAT,
               ROUND(DATE_TO - DATE_FROM) ORD_DAYS,
               MON_DAYS
          FROM ( 
            SELECT B.BILL_ID, B.REP_PERIOD_ID, O.ACCOUNT_ID, 
                   O.ORDER_ID, O.SERVICE_ID, 
                   OB.ORDER_BODY_ID, OB.SUBSERVICE_ID, OB.CHARGE_TYPE,
                   GREATEST(P.PERIOD_FROM, O.DATE_FROM) DATE_FROM, 
                   LEAST(NVL(O.DATE_TO, P.PERIOD_TO),P.PERIOD_TO) DATE_TO, 
                   OB.TAX_INCL, 
                   CASE
                     WHEN OB.CURRENCY_ID = Pk00_Const.c_CURRENCY_YE_FIX THEN (OB.RATE_VALUE * 28.6)
                     ELSE OB.RATE_VALUE
                   END MIN_VALUE,
                   AP.VAT,
                   ROUND(P.PERIOD_TO - P.PERIOD_FROM) MON_DAYS
              FROM ORDER_T O, ORDER_BODY_T OB, 
                   BILL_T B, ACCOUNT_PROFILE_T AP, 
                   BILLING_QUEUE_T BQ, PERIOD_T P
             WHERE (P.PERIOD_FROM <= O.DATE_TO OR O.DATE_TO IS NULL)
               AND O.DATE_FROM    <= P.PERIOD_TO
               AND (P.PERIOD_FROM <= OB.DATE_TO OR OB.DATE_TO IS NULL)
               AND OB.DATE_FROM   <= P.PERIOD_TO
               AND OB.CHARGE_TYPE  = Pk00_Const.c_CHARGE_TYPE_MIN -- 'MIN'
               AND OB.RATE_LEVEL_ID= Pk00_Const.c_RATE_LEVEL_SUBSRV
               AND OB.ORDER_ID     = O.ORDER_ID
               AND B.ACCOUNT_ID    = O.ACCOUNT_ID
               AND B.ACCOUNT_ID    = AP.ACCOUNT_ID
               AND B.PROFILE_ID    = AP.PROFILE_ID
               AND B.REP_PERIOD_ID = BQ.REP_PERIOD_ID
               AND B.ACCOUNT_ID    = BQ.ACCOUNT_ID
               AND B.BILL_ID       = BQ.BILL_ID
               AND B.BILL_TYPE     IN (Pk00_Const.c_BILL_TYPE_REC, 
                                       Pk00_Const.c_BILL_TYPE_DBT, 
                                       Pk00_Const.c_BILL_TYPE_OLD)
               AND P.PERIOD_ID     = NVL(BQ.DATA_PERIOD_ID, BQ.REP_PERIOD_ID)
               AND BQ.TASK_ID      = p_task_id
        )
    ), IT AS (
        SELECT I.BILL_ID, I.REP_PERIOD_ID, 
               I.ORDER_ID, I.SERVICE_ID, I.SUBSERVICE_ID,
               I.TAX_INCL, SUM(I.ITEM_TOTAL) SUM_ITEM_TOTAL
          FROM ITEM_T I, ORDER_BODY_T OB, 
               BILLING_QUEUE_T BQ, PERIOD_T P
         WHERE OB.CHARGE_TYPE  = Pk00_Const.c_CHARGE_TYPE_MIN -- 'MIN'
           AND OB.RATE_LEVEL_ID= Pk00_Const.c_RATE_LEVEL_SUBSRV
           AND OB.DATE_FROM   <= P.PERIOD_TO
           AND (P.PERIOD_FROM <= OB.DATE_TO OR OB.DATE_TO IS NULL)
           AND I.CHARGE_TYPE   = Pk00_Const.c_CHARGE_TYPE_USG -- 'USG'    -- только трафик 
           AND I.REP_PERIOD_ID = BQ.REP_PERIOD_ID
           AND I.DATE_FROM    <= P.PERIOD_TO        -- рассматриваем только item-s
           AND I.DATE_TO      >= P.PERIOD_FROM      -- указанного периода
           AND I.SUBSERVICE_ID = OB.SUBSERVICE_ID
           AND I.BILL_ID       = BQ.BILL_ID
           AND P.PERIOD_ID     = NVL(BQ.DATA_PERIOD_ID, BQ.REP_PERIOD_ID)
           AND BQ.TASK_ID      = p_task_id
         GROUP BY I.BILL_ID, I.REP_PERIOD_ID, 
                  I.ORDER_ID, I.SERVICE_ID, I.SUBSERVICE_ID, I.TAX_INCL
    ), ITM AS ( 
      SELECT 
           MP.ACCOUNT_ID, MP.ORDER_ID, MP.ORDER_BODY_ID,
           MP.SERVICE_ID, MP.SUBSERVICE_ID,
           MP.DATE_FROM, MP.DATE_TO, MP.CHARGE_TYPE, 
           MP.BILL_ID, MP.REP_PERIOD_ID, 
           NVL(IT.SUM_ITEM_TOTAL,0) SUM_ITEM_TOTAL, 
           NVL(IT.TAX_INCL, MP.TAX_INCL) IT_TAX_INCL,
           CASE 
             WHEN IT.TAX_INCL = 'N' AND MP.TAX_INCL = 'Y' THEN ROUND(MP.MIN_VALUE /(1 + MP.VAT / 100),2) 
             WHEN IT.TAX_INCL = 'Y' AND MP.TAX_INCL = 'N' THEN MP.MIN_VALUE + ROUND(MP.MIN_VALUE * MP.VAT / 100, 2)
             ELSE MP.MIN_VALUE 
           END MIN_VALUE,
           NVL(LCK.LCK_DAYS,0) LCK_DAYS,
           ((MP.ORD_DAYS - NVL(LCK.LCK_DAYS,0))/MON_DAYS) K_DAYS
        FROM MP, IT, LCK
       WHERE MP.BILL_ID       = IT.BILL_ID(+)
         AND MP.REP_PERIOD_ID = IT.REP_PERIOD_ID(+)
         AND MP.ORDER_ID      = IT.ORDER_ID(+)
         AND MP.SERVICE_ID    = IT.SERVICE_ID(+)
         AND MP.SUBSERVICE_ID = IT.SUBSERVICE_ID(+)
         AND MP.ORDER_ID      = LCK.ORDER_ID(+)
         AND MP.BILL_ID       = LCK.BILL_ID(+) 
         AND MP.REP_PERIOD_ID = LCK.REP_PERIOD_ID(+)
    )
    SELECT BILL_ID, REP_PERIOD_ID, SQ_ITEM_ID.NEXTVAL ITEM_ID, ORDER_ID, 
           SERVICE_ID, 
           --Pk00_Const.c_SUBSRV_MIN SUBSERVICE_ID, -- 
           SUBSERVICE_ID, --(решение А.Ю.Гурова)
           CHARGE_TYPE,
           ROUND((K_DAYS * MIN_VALUE - SUM_ITEM_TOTAL),2) ITEM_TOTAL,
           DATE_FROM, DATE_TO, IT_TAX_INCL, 
           PK00_CONST.c_ITEM_TYPE_BILL,
           Pk00_Const.c_ITEM_STATE_OPEN,
           ORDER_BODY_ID 
      FROM ITM
     WHERE K_DAYS > 0
       AND ROUND((K_DAYS * MIN_VALUE - SUM_ITEM_TOTAL),2) > 0
    ;
    v_count := SQL%ROWCOUNT;
    Pk01_Syslog.Write_msg('Item_t: '||v_count||' rows created ', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    Pk01_Syslog.Write_msg('Stop.', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
EXCEPTION WHEN OTHERS THEN
    Pk01_Syslog.raise_Exception('ERROR', c_PkgName||'.'||v_prcName );
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
--  Расчет доплаты до мимнимальной суммы ЗАКАЗА
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
PROCEDURE Order_charge_MIN( p_task_id IN INTEGER )    
IS
    v_prcName       CONSTANT VARCHAR2(30) := 'Order_charge_MIN';
    v_count         INTEGER;
BEGIN
    Pk01_Syslog.Write_msg('Start, task_id = '||p_task_id, c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Создаем позиции начислений доплаты до мимнимальной суммы ЗАКАЗА
    --
    INSERT INTO ITEM_T(
        BILL_ID, REP_PERIOD_ID, ITEM_ID, ORDER_ID, SERVICE_ID, SUBSERVICE_ID, 
        CHARGE_TYPE, ITEM_TOTAL, DATE_FROM, DATE_TO, TAX_INCL, ITEM_TYPE,
        ITEM_STATUS, ORDER_BODY_ID
    )
    WITH LCK AS (
        SELECT BILL_ID, REP_PERIOD_ID,
               ORDER_ID, ROUND(SUM(LOCK_DAYS)) LCK_DAYS
          FROM (
            -- -------------------------------------------------------------------- --
            SELECT Q.BILL_ID, Q.REP_PERIOD_ID, L.ORDER_ID, 
                   CASE 
                    -- заблокирован весь месяц:  DATE_FROM---[-------]---DATE_TO
                    WHEN L.DATE_FROM <= P.PERIOD_FROM 
                     AND (P.PERIOD_TO <= L.DATE_TO OR L.DATE_TO IS NULL) 
                    THEN P.PERIOD_TO - P.PERIOD_FROM
                    -- заблокирован внутри месяца: [--DATE_FROM-----DATE_TO--]
                    WHEN P.PERIOD_FROM < L.DATE_FROM 
                     AND L.DATE_TO < P.PERIOD_TO 
                    THEN L.DATE_TO - L.DATE_FROM
                    -- заблокирован в предыдущем периоде, открыт в текущем: ---DATE_FROM-- [---DATE_TO---]
                    WHEN L.DATE_FROM <= P.PERIOD_FROM 
                     AND L.DATE_TO < P.PERIOD_TO 
                    THEN L.DATE_TO - P.PERIOD_FROM
                    -- заблокирован в текущем периоде, и остается до конца периода:---[--DATE_FROM--]---DATE_TO---  
                    WHEN P.PERIOD_FROM < L.DATE_FROM  
                     AND (P.PERIOD_TO <= L.DATE_TO OR L.DATE_TO IS NULL)
                    THEN P.PERIOD_TO - L.DATE_FROM
                    -- возможем некорректный ввод
                    ELSE 0
                   END LOCK_DAYS
              FROM ORDER_LOCK_T L, ORDER_T O, BILLING_QUEUE_T Q, PERIOD_T P
            WHERE L.DATE_FROM    <= P.PERIOD_TO                     -- только блокировки 
              AND (L.DATE_TO IS NULL OR P.PERIOD_FROM <= L.DATE_TO) -- действовавшие в периоде
              AND O.ORDER_ID      = L.ORDER_ID
              AND Q.ACCOUNT_ID    = O.ACCOUNT_ID
              AND P.PERIOD_ID     = NVL(Q.DATA_PERIOD_ID, Q.REP_PERIOD_ID)
              AND Q.TASK_ID       = p_task_id
            -- -------------------------------------------------------------------- --
        )
        GROUP BY BILL_ID, REP_PERIOD_ID, ORDER_ID
    ), MP AS (
        SELECT BILL_ID, REP_PERIOD_ID, 
               ACCOUNT_ID, ORDER_ID, ORDER_BODY_ID,
               SERVICE_ID, CHARGE_TYPE, 
               DATE_FROM, DATE_TO, TAX_INCL, MIN_VALUE, VAT,
               ROUND(DATE_TO - DATE_FROM) ORD_DAYS,
               MON_DAYS
          FROM ( 
            SELECT B.BILL_ID, B.REP_PERIOD_ID, 
                   O.ACCOUNT_ID, O.ORDER_ID, OB.ORDER_BODY_ID,
                   O.SERVICE_ID, OB.CHARGE_TYPE,
                   GREATEST(P.PERIOD_FROM, O.DATE_FROM) DATE_FROM, 
                   LEAST( NVL(O.DATE_TO, P.PERIOD_TO), P.PERIOD_TO) DATE_TO, 
                   OB.TAX_INCL, 
                   CASE
                     WHEN OB.CURRENCY_ID = Pk00_Const.c_CURRENCY_YE_FIX THEN (OB.RATE_VALUE * 28.6)
                     ELSE OB.RATE_VALUE
                   END MIN_VALUE,
                   AP.VAT,
                   ROUND(P.PERIOD_TO - P.PERIOD_FROM) MON_DAYS
              FROM ORDER_T O, ORDER_BODY_T OB, 
                   BILL_T B, ACCOUNT_PROFILE_T AP, 
                   BILLING_QUEUE_T BQ, PERIOD_T P
             WHERE OB.CHARGE_TYPE  = Pk00_Const.c_CHARGE_TYPE_MIN -- 'MIN'
               AND OB.RATE_LEVEL_ID= Pk00_Const.c_RATE_LEVEL_ORDER
               AND OB.DATE_FROM   <= P.PERIOD_TO
               AND (P.PERIOD_FROM <= OB.DATE_TO OR OB.DATE_TO IS NULL)
               AND OB.ORDER_ID     = O.ORDER_ID
               AND O.DATE_FROM    <= P.PERIOD_TO             
               AND (P.PERIOD_FROM <= O.DATE_TO OR O.DATE_TO IS NULL)
               AND B.ACCOUNT_ID    = O.ACCOUNT_ID
               AND B.ACCOUNT_ID    = AP.ACCOUNT_ID
               AND B.PROFILE_ID   = AP.PROFILE_ID
               AND B.REP_PERIOD_ID = BQ.REP_PERIOD_ID
               AND B.ACCOUNT_ID    = BQ.ACCOUNT_ID
               AND B.BILL_ID       = BQ.BILL_ID
               AND B.BILL_TYPE     IN (Pk00_Const.c_BILL_TYPE_REC, 
                                       Pk00_Const.c_BILL_TYPE_DBT, 
                                       Pk00_Const.c_BILL_TYPE_OLD)
               AND P.PERIOD_ID     = NVL(BQ.DATA_PERIOD_ID, BQ.REP_PERIOD_ID)
               AND BQ.TASK_ID      = p_task_id
        )
    ), IT AS (
        SELECT I.BILL_ID, I.REP_PERIOD_ID, I.ORDER_ID, I.SERVICE_ID, I.TAX_INCL, SUM(I.ITEM_TOTAL) SUM_ITEM_TOTAL
          FROM ITEM_T I, ORDER_BODY_T OB, BILLING_QUEUE_T BQ, PERIOD_T P
         WHERE OB.CHARGE_TYPE  = Pk00_Const.c_CHARGE_TYPE_MIN -- 'MIN'
           AND OB.RATE_LEVEL_ID= Pk00_Const.c_RATE_LEVEL_ORDER
           AND OB.DATE_FROM   <= P.PERIOD_TO
           AND (P.PERIOD_FROM <= OB.DATE_TO OR OB.DATE_TO IS NULL)
           AND OB.ORDER_ID     = I.ORDER_ID
           AND I.CHARGE_TYPE   = Pk00_Const.c_CHARGE_TYPE_USG -- 'USG'    -- только трафик 
           AND I.REP_PERIOD_ID = BQ.REP_PERIOD_ID
           AND I.DATE_FROM    <= P.PERIOD_TO        -- рассматриваем только item-s
           AND I.DATE_TO      >= P.PERIOD_FROM      -- указанного периода
           AND I.BILL_ID       = BQ.BILL_ID
           AND P.PERIOD_ID     = NVL(BQ.DATA_PERIOD_ID, BQ.REP_PERIOD_ID)
           AND BQ.TASK_ID      = p_task_id
         GROUP BY I.BILL_ID, I.REP_PERIOD_ID, I.ORDER_ID, I.SERVICE_ID, I.TAX_INCL
    ), ITM AS ( 
      SELECT 
           MP.ACCOUNT_ID, MP.ORDER_ID, MP.ORDER_BODY_ID, MP.SERVICE_ID, 
           MP.DATE_FROM, MP.DATE_TO, MP.CHARGE_TYPE, 
           MP.BILL_ID, MP.REP_PERIOD_ID, 
           NVL(IT.SUM_ITEM_TOTAL,0) SUM_ITEM_TOTAL, 
           NVL(IT.TAX_INCL, MP.TAX_INCL) IT_TAX_INCL,
           CASE 
             WHEN IT.TAX_INCL = 'N' AND MP.TAX_INCL = 'Y' THEN ROUND(MP.MIN_VALUE /(1 + MP.VAT / 100),2) 
             WHEN IT.TAX_INCL = 'Y' AND MP.TAX_INCL = 'N' THEN MP.MIN_VALUE + ROUND(MP.MIN_VALUE * MP.VAT / 100, 2)
             ELSE MP.MIN_VALUE 
           END MIN_VALUE,
           NVL(LCK.LCK_DAYS,0) LCK_DAYS,
           ((MP.ORD_DAYS - NVL(LCK.LCK_DAYS,0))/MON_DAYS) K_DAYS
        FROM MP, IT, LCK
       WHERE MP.BILL_ID       = IT.BILL_ID(+)
         AND MP.REP_PERIOD_ID = IT.REP_PERIOD_ID(+)
         AND MP.ORDER_ID      = IT.ORDER_ID(+)
         AND MP.SERVICE_ID    = IT.SERVICE_ID(+)
         AND MP.ORDER_ID      = LCK.ORDER_ID(+)
         AND MP.BILL_ID       = LCK.BILL_ID(+) 
         AND MP.REP_PERIOD_ID = LCK.REP_PERIOD_ID(+)
    )
    SELECT BILL_ID, REP_PERIOD_ID, SQ_ITEM_ID.NEXTVAL ITEM_ID, ORDER_ID, 
           SERVICE_ID, Pk00_Const.c_SUBSRV_MIN SUBSERVICE_ID, CHARGE_TYPE,
           ROUND((K_DAYS * MIN_VALUE - SUM_ITEM_TOTAL),2) ITEM_TOTAL,
           DATE_FROM, DATE_TO, IT_TAX_INCL, 
           PK00_CONST.c_ITEM_TYPE_BILL,
           Pk00_Const.c_ITEM_STATE_OPEN,
           ORDER_BODY_ID 
      FROM ITM
     WHERE K_DAYS > 0
       AND ROUND((K_DAYS * MIN_VALUE - SUM_ITEM_TOTAL),2) > 0
       
    ;
    v_count := SQL%ROWCOUNT;
    Pk01_Syslog.Write_msg('Item_t: '||v_count||' rows created ', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    Pk01_Syslog.Write_msg('Stop.', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
EXCEPTION WHEN OTHERS THEN
    Pk01_Syslog.raise_Exception('ERROR', c_PkgName||'.'||v_prcName );
END;

-- ----------------------------------------------------------------- --
--  Расчет доплаты до мимнимальной суммы Лицевого счета
-- ----------------------------------------------------------------- --
PROCEDURE Account_charge_MIN( p_task_id IN INTEGER )
IS
    v_prcName       CONSTANT VARCHAR2(30) := 'Account_charge_MIN';
    v_count         INTEGER;
BEGIN
    Pk01_Syslog.Write_msg('Start, task_id = '||p_task_id, c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Создаем позиции начислений доплаты до мимнимальной суммы ПЕРИОДИЧЕСКОГО СЧЕТА по Л/С
    --
    INSERT INTO ITEM_T(
        BILL_ID, REP_PERIOD_ID, ITEM_ID, ORDER_ID, SERVICE_ID, SUBSERVICE_ID, 
        CHARGE_TYPE, ITEM_TOTAL, DATE_FROM, DATE_TO, TAX_INCL, ITEM_TYPE,
        ITEM_STATUS, ORDER_BODY_ID
    )
    WITH LCK AS (
        SELECT BILL_ID, REP_PERIOD_ID,
               ORDER_ID, ROUND(SUM(LOCK_DAYS)) LCK_DAYS
          FROM (
            -- -------------------------------------------------------------------- --
            SELECT Q.BILL_ID, Q.REP_PERIOD_ID, L.ORDER_ID, 
                   CASE 
                    -- заблокирован весь месяц:  DATE_FROM---[-------]---DATE_TO
                    WHEN L.DATE_FROM <= P.PERIOD_FROM 
                     AND (P.PERIOD_TO <= L.DATE_TO OR L.DATE_TO IS NULL) 
                    THEN P.PERIOD_TO - P.PERIOD_FROM
                    -- заблокирован внутри месяца: [--DATE_FROM-----DATE_TO--]
                    WHEN P.PERIOD_FROM < L.DATE_FROM 
                     AND L.DATE_TO < P.PERIOD_TO 
                    THEN L.DATE_TO - L.DATE_FROM
                    -- заблокирован в предыдущем периоде, открыт в текущем: ---DATE_FROM-- [---DATE_TO---]
                    WHEN L.DATE_FROM <= P.PERIOD_FROM 
                     AND L.DATE_TO < P.PERIOD_TO 
                    THEN L.DATE_TO - P.PERIOD_FROM
                    -- заблокирован в текущем периоде, и остается до конца периода:---[--DATE_FROM--]---DATE_TO---  
                    WHEN P.PERIOD_FROM < L.DATE_FROM  
                     AND (P.PERIOD_TO <= L.DATE_TO OR L.DATE_TO IS NULL)
                    THEN P.PERIOD_TO - L.DATE_FROM
                    -- возможем некорректный ввод
                    ELSE 0
                   END LOCK_DAYS
              FROM ORDER_LOCK_T L, ORDER_T O, BILLING_QUEUE_T Q, PERIOD_T P
            WHERE L.DATE_FROM    <= P.PERIOD_TO                     -- только блокировки 
              AND (L.DATE_TO IS NULL OR P.PERIOD_FROM <= L.DATE_TO) -- действовавшие в периоде
              AND O.ORDER_ID      = L.ORDER_ID
              AND Q.ACCOUNT_ID    = O.ACCOUNT_ID
              AND P.PERIOD_ID     = NVL(Q.DATA_PERIOD_ID, Q.REP_PERIOD_ID)
              AND Q.TASK_ID       = p_task_id
            -- -------------------------------------------------------------------- --
        )
        GROUP BY BILL_ID, REP_PERIOD_ID, ORDER_ID
    ), MP AS (
        SELECT BILL_ID, REP_PERIOD_ID, 
               ACCOUNT_ID, ORDER_ID, ORDER_BODY_ID,
               SERVICE_ID, CHARGE_TYPE, 
               DATE_FROM, DATE_TO, TAX_INCL, MIN_VALUE, VAT,
               ROUND(DATE_TO - DATE_FROM) ORD_DAYS,
               MON_DAYS
          FROM ( 
            SELECT B.BILL_ID, B.REP_PERIOD_ID, 
                   O.ACCOUNT_ID, O.ORDER_ID, OB.ORDER_BODY_ID,
                   O.SERVICE_ID, OB.CHARGE_TYPE,
                   GREATEST(P.PERIOD_FROM, AP.DATE_FROM) DATE_FROM, 
                   LEAST(NVL(AP.DATE_TO, P.PERIOD_TO), P.PERIOD_TO) DATE_TO, 
                   OB.TAX_INCL, 
                   CASE
                     WHEN OB.CURRENCY_ID = Pk00_Const.c_CURRENCY_YE_FIX THEN (OB.RATE_VALUE * 28.6)
                     ELSE OB.RATE_VALUE
                   END MIN_VALUE,
                   AP.VAT,
                   ROUND(P.PERIOD_TO - P.PERIOD_FROM) MON_DAYS
              FROM ORDER_T O, ORDER_BODY_T OB, 
                   BILL_T B, ACCOUNT_PROFILE_T AP, 
                   BILLING_QUEUE_T BQ, PERIOD_T P
             WHERE OB.CHARGE_TYPE  = Pk00_Const.c_CHARGE_TYPE_MIN -- 'MIN'
               AND OB.RATE_LEVEL_ID= Pk00_Const.c_RATE_LEVEL_ACCOUNT
               AND OB.DATE_FROM   <= P.PERIOD_TO
               AND (P.PERIOD_FROM <= OB.DATE_TO OR OB.DATE_TO IS NULL)
               AND OB.ORDER_ID     = O.ORDER_ID
               AND B.ACCOUNT_ID    = O.ACCOUNT_ID
               AND B.ACCOUNT_ID    = AP.ACCOUNT_ID
               AND B.ACCOUNT_ID    = AP.ACCOUNT_ID
               AND B.PROFILE_ID    = AP.PROFILE_ID
               AND B.REP_PERIOD_ID = BQ.REP_PERIOD_ID
               AND B.ACCOUNT_ID    = BQ.ACCOUNT_ID
               AND B.BILL_ID       = BQ.BILL_ID
               AND B.BILL_TYPE     IN (Pk00_Const.c_BILL_TYPE_REC, 
                                       Pk00_Const.c_BILL_TYPE_DBT, 
                                       Pk00_Const.c_BILL_TYPE_OLD)
               AND P.PERIOD_ID     = NVL(BQ.DATA_PERIOD_ID, BQ.REP_PERIOD_ID)
               AND BQ.TASK_ID      = p_task_id
        )
    ), IT AS (
        SELECT I.BILL_ID, I.REP_PERIOD_ID, I.TAX_INCL, 
               SUM(I.ITEM_TOTAL) SUM_ITEM_TOTAL
          FROM ITEM_T I, ORDER_BODY_T OB, ORDER_T O, BILLING_QUEUE_T BQ, PERIOD_T P
         WHERE OB.CHARGE_TYPE  = Pk00_Const.c_CHARGE_TYPE_MIN -- 'MIN'
           AND OB.RATE_LEVEL_ID= Pk00_Const.c_RATE_LEVEL_ACCOUNT
           AND OB.DATE_FROM   <= P.PERIOD_TO
           AND (P.PERIOD_FROM <= OB.DATE_TO OR OB.DATE_TO IS NULL)
           AND OB.ORDER_ID     = O.ORDER_ID 
           AND O.ACCOUNT_ID    = BQ.ACCOUNT_ID
           AND I.CHARGE_TYPE   = Pk00_Const.c_CHARGE_TYPE_USG -- 'USG'    -- только трафик
           AND I.REP_PERIOD_ID = BQ.REP_PERIOD_ID
           AND I.DATE_FROM    <= P.PERIOD_TO        -- рассматриваем только item-s
           AND I.DATE_TO      >= P.PERIOD_FROM      -- указанного периода
           AND I.BILL_ID       = BQ.BILL_ID
           AND P.PERIOD_ID     = NVL(BQ.DATA_PERIOD_ID, BQ.REP_PERIOD_ID)
           AND BQ.TASK_ID      = p_task_id
         GROUP BY I.BILL_ID, I.REP_PERIOD_ID, I.TAX_INCL
    ), ITM AS ( 
      SELECT 
           MP.ACCOUNT_ID, MP.ORDER_ID, MP.ORDER_BODY_ID, MP.SERVICE_ID, 
           MP.DATE_FROM, MP.DATE_TO, MP.CHARGE_TYPE, 
           MP.BILL_ID, MP.REP_PERIOD_ID, 
           NVL(IT.SUM_ITEM_TOTAL,0) SUM_ITEM_TOTAL, 
           NVL(IT.TAX_INCL, MP.TAX_INCL) IT_TAX_INCL,
           CASE 
             WHEN IT.TAX_INCL = 'N' AND MP.TAX_INCL = 'Y' THEN ROUND(MP.MIN_VALUE /(1 + MP.VAT / 100),2) 
             WHEN IT.TAX_INCL = 'Y' AND MP.TAX_INCL = 'N' THEN MP.MIN_VALUE + ROUND(MP.MIN_VALUE * MP.VAT / 100, 2)
             ELSE MP.MIN_VALUE 
           END MIN_VALUE,
           NVL(LCK.LCK_DAYS,0) LCK_DAYS,
           ((MP.ORD_DAYS - NVL(LCK.LCK_DAYS,0))/MON_DAYS) K_DAYS
        FROM MP, IT, LCK
       WHERE MP.BILL_ID       = IT.BILL_ID(+)
         AND MP.REP_PERIOD_ID = IT.REP_PERIOD_ID(+)
         AND MP.ORDER_ID      = LCK.ORDER_ID(+)
         AND MP.BILL_ID       = LCK.BILL_ID(+) 
         AND MP.REP_PERIOD_ID = LCK.REP_PERIOD_ID(+)
    )
    SELECT BILL_ID, REP_PERIOD_ID, SQ_ITEM_ID.NEXTVAL ITEM_ID, ORDER_ID, 
           SERVICE_ID, Pk00_Const.c_SUBSRV_MIN SUBSERVICE_ID, CHARGE_TYPE,
           ROUND((K_DAYS * MIN_VALUE - SUM_ITEM_TOTAL),2) ITEM_TOTAL,
           DATE_FROM, DATE_TO, IT_TAX_INCL, 
           PK00_CONST.c_ITEM_TYPE_BILL,
           Pk00_Const.c_ITEM_STATE_OPEN,
           ORDER_BODY_ID 
      FROM ITM
     WHERE K_DAYS > 0
       AND ROUND((K_DAYS * MIN_VALUE - SUM_ITEM_TOTAL),2) > 0
    ;

    v_count := SQL%ROWCOUNT;
    Pk01_Syslog.Write_msg('Item_t: '||v_count||' rows created ', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    Pk01_Syslog.Write_msg('Stop.', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
EXCEPTION WHEN OTHERS THEN
    Pk01_Syslog.raise_Exception('ERROR', c_PkgName||'.'||v_prcName );
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Расформирование фиксированных начислений,
-- за исключением тех что сформировал тарификатор трафика
--
PROCEDURE Rollback_fixrates( p_task_id IN INTEGER )
IS
    v_prcName    CONSTANT VARCHAR2(30) := 'Rollback_fixrates';
    v_count      INTEGER;
BEGIN
    Pk01_Syslog.Write_msg('Start', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --    
    DELETE FROM ITEM_T I
     WHERE I.CHARGE_TYPE IN (
                           Pk00_Const.c_CHARGE_TYPE_MIN, 
                           Pk00_Const.c_CHARGE_TYPE_REC)
       AND I.ITEM_STATUS = Pk00_Const.c_ITEM_STATE_OPEN
       AND I.ITEM_TYPE   = PK00_CONST.c_ITEM_TYPE_BILL
       AND I.EXTERNAL_ID IS NULL -- это важно, чтобы не зацепить мимнималки, сформированные предбиллингом
       AND EXISTS (
        SELECT * FROM BILLING_QUEUE_T Q
         WHERE Q.BILL_ID       = I.BILL_ID
           AND Q.REP_PERIOD_ID = I.REP_PERIOD_ID
           AND (Q.DATA_PERIOD_ID IS NULL 
                OR Q.DATA_PERIOD_ID = PK04_PERIOD.Period_id(I.DATE_FROM)
                )
           AND Q.TASK_ID       = p_task_id
    );
    v_count := SQL%ROWCOUNT;
    --
    Pk01_Syslog.Write_msg('Stop. '||v_count||' rows deleted', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --    
EXCEPTION
    WHEN OTHERS THEN
        Pk01_Syslog.raise_Exception('Stop.ERROR', c_PkgName||'.'||v_prcName );
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Начисление абонентской платы и доплаты до минимальной суммы
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
PROCEDURE Charge_fixrates( p_task_id IN INTEGER )
IS
    v_prcName    CONSTANT VARCHAR2(30) := 'Charge_fixrates';
BEGIN
    Pk01_Syslog.Write_msg('Start', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Начисление абонентской платы
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    Charge_ABP( p_task_id => p_task_id );

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    --  Расчет абонплаты (subscriber fee) по тарифам укзанным 
    -- индивидуально для каждого месяца (MONTH_TARIFF_T),
    -- такой тариф иногда требуют бюджетные организации, 
    -- заключающие договор на один год, затем тендер и новый договор
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    Charge_ABP_by_month_tariff( p_task_id => p_task_id );

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    -- Начисление доплаты до минимальной суммы
    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
    --  Расчет доплаты до мимнимальной суммы КОМПОМЕНТА УСЛУГИ ЗАКАЗА
    Subservice_charge_MIN( p_task_id => p_task_id );

    --  Расчет доплаты до мимнимальной суммы ЗАКАЗА
    Order_charge_MIN( p_task_id => p_task_id );
    
    --  Расчет доплаты до мимнимальной суммы Лицевого счета
    Account_charge_MIN( p_task_id => p_task_id );

    --  Заполнить поля необходимые для получения детализации по абонплате
    Put_abp_detail( p_task_id => p_task_id );
    
    Pk01_Syslog.Write_msg('Stop', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --
EXCEPTION
    WHEN OTHERS THEN
        Pk01_Syslog.raise_Exception('Stop.ERROR', c_PkgName||'.'||v_prcName );
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Нестандартные правила начисления АБП и Доплаты до минималки
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
PROCEDURE Charge_non_std_fixrates( p_bill_period_id IN INTEGER )
IS
    v_prcName      CONSTANT VARCHAR2(30) := 'Charge_non_std_fixrates';
    v_count        INTEGER;
    v_task_id      INTEGER;
    v_item_total   NUMBER;
    v_bill_minutes NUMBER;
    v_charge_value NUMBER;
    v_period_from  DATE;
    v_period_to    DATE;

BEGIN
    Pk01_Syslog.Write_msg('Start', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --
    v_task_id     := PK30_BILLING_QUEUE.Open_task;
    v_period_from := Pk04_Period.Period_from(p_bill_period_id);
    v_period_to   := Pk04_Period.Period_to(p_bill_period_id);
    --
    -- заполняем очередь
    INSERT INTO BILLING_QUEUE_T(BILL_ID, ACCOUNT_ID, BILLING_ID, PROFILE_ID, 
                TASK_ID, REP_PERIOD_ID)
    SELECT DISTINCT 
           B.BILL_ID, B.ACCOUNT_ID, A.BILLING_ID, B.PROFILE_ID,
           v_task_id, B.REP_PERIOD_ID
      FROM ACCOUNT_T A, ORDER_T O, ORDER_BODY_T OB,
           ITEM_T I, BILL_T B 
     WHERE B.REP_PERIOD_ID = p_bill_period_id
       AND B.ACCOUNT_ID    = A.ACCOUNT_ID
       AND O.ACCOUNT_ID    = A.ACCOUNT_ID
       AND O.ORDER_ID      = OB.ORDER_ID
       AND OB.RATE_RULE_ID IN ( 2430, 2431 ) 
    ;
    --   
    FOR rq IN (
        SELECT Q.BILL_ID, Q.ACCOUNT_ID, Q.PROFILE_ID, Q.REP_PERIOD_ID, Q.DATA_PERIOD_ID,
               O.ORDER_ID, O.ORDER_NO, OB.ORDER_BODY_ID, OB.RATE_RULE_ID, 
               O.SERVICE_ID, OB.SUBSERVICE_ID
          FROM BILLING_QUEUE_T Q, ORDER_T O, ORDER_BODY_T OB, ACCOUNT_T A
         WHERE Q.TASK_ID    = v_task_id
           AND Q.ACCOUNT_ID = A.ACCOUNT_ID
           AND Q.ACCOUNT_ID = O.ACCOUNT_ID
           AND O.ORDER_ID   = OB.ORDER_ID
           AND OB.RATE_RULE_ID IN (2430, 2431) -- для страховки
      )
    LOOP
      IF rq.Rate_Rule_Id = 2430 THEN
          -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
          -- RATE_RULE_ID = 2430
          -- a.    л/с RP001190 ООО "Смарт Телеком"
          -- гарантированный объем трафика считается по двум статьям:
          -- LTERM019 (10050) Местное завершение вызова на сеть другого оператора
          -- LTERM022 (10010) Местное завершение вызова на нумерацию сети связи ОАО «Ростелеком» в коде 812
          -- и составляет 30 000 мин * 15 Е1 = 450 000 мин, недобор выставляется по тарифу 0.25 р/мин
          --
          -- получаем сумму начислений
          SELECT SUM(ITEM_TOTAL) 
            INTO v_item_total
            FROM ITEM_T I
           WHERE I.BILL_ID       = rq.bill_id
             AND I.REP_PERIOD_ID = rq.rep_period_id
             AND I.SUBSERVICE_ID IN (10050, 10010);

          -- получаем кол-во минут
          SELECT --+ parallel(b 10)
             --TRUNC(b.local_time,'mm') debt_month,
             -- account_id, order_id,   
             --(CASE trf_type  
             --   WHEN 1 THEN 'Завершение'
             --   WHEN 2 THEN 'Инициирование'
             --   WHEN 5 THEN 'Инициирование на платформу'
             -- END) srv_name,
              --COUNT(1) calls,
              ROUND(SUM(bill_minutes),2) bill_minutes
              --ROUND(SUM(duration),2) cdr_seconds,
              --ROUND(SUM(amount),2) amount,
              --MIN(local_time) first_call,
              --MAX(local_time) last_call
              INTO v_bill_minutes
              FROM bdr_oper_t b
             WHERE rep_period between v_period_from AND v_period_to 
               AND bdr_status    = 0
               AND bdr_type_id   = 3
               AND trf_type      IN (1,2,5)
               AND account_id    = rq.account_id
               --AND order_id      = rq.order_id
               AND subservice_id IN (10050, 10010)
             --GROUP BY TRUNC(b.local_time,'mm'), account_id, order_id, trf_type
          ;
          --
          IF v_bill_minutes < 450000 THEN
              v_charge_value := (450000 - v_bill_minutes) * 0.25;
              -- проводим начисления
              INSERT INTO ITEM_T I(
                 BILL_ID, REP_PERIOD_ID, ITEM_ID, ORDER_ID, SERVICE_ID, SUBSERVICE_ID, 
                 CHARGE_TYPE, ITEM_TOTAL, DATE_FROM, DATE_TO, TAX_INCL, ITEM_TYPE,
                 ITEM_STATUS, ORDER_BODY_ID
              ) VALUES (
                 rq.bill_id, rq.rep_period_id, Pk02_Poid.Next_item_id, rq.order_id,
                 Pk00_Const.c_SERVICE_OP_LOCAL, Pk00_Const.c_SUBSRV_MIN,
                 Pk00_Const.c_CHARGE_TYPE_MIN, v_charge_value,
                 v_period_from, v_period_to, 'N', Pk00_Const.c_ITEM_TYPE_BILL,
                 Pk00_Const.c_ITEM_STATE_OPEN, rq.order_body_id
              );
              --
              Pk01_Syslog.Write_msg('Bill_id='||rq.bill_id||' RR=2430 - charged', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
          END IF;      
      ELSIF rq.Rate_Rule_Id = 2431 THEN
          -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
          -- RATE_RULE_ID = 2431
          -- b.    л/с RP001186 ЗАО "VMB-Сервис"
          -- гарантированный объем трафика считается по всем статьям завершения на СПС:
          -- ZTERM007(10015) Зоновое завершение вызова на СПС сеть "МТС" и "Мегафон"
          -- ZTERM003(10052) Зоновое завершение вызова на сети СПС «Санкт-Петербург Телеком» (Теле-2)
          -- ZTERM012(10076) Зоновое завершение на СПС ОАО "МТТ"
          -- ZTERM001(10053) Зоновое завершение вызова на сети СПС «Вымпелком»
          -- и составляет 30 000 руб/мес
          --
          -- получаем сумму начислений
          SELECT SUM(ITEM_TOTAL) 
            INTO v_item_total
            FROM ITEM_T I
           WHERE I.BILL_ID       = rq.bill_id
             AND I.REP_PERIOD_ID = rq.rep_period_id
             AND I.SUBSERVICE_ID IN (10053,10052,10015,10076);
          --
          IF v_item_total < 30000 THEN
              v_charge_value := 30000 - v_item_total;
              -- проводим начисления
              INSERT INTO ITEM_T I(
                 BILL_ID, REP_PERIOD_ID, ITEM_ID, ORDER_ID, SERVICE_ID, SUBSERVICE_ID, 
                 CHARGE_TYPE, ITEM_TOTAL, DATE_FROM, DATE_TO, TAX_INCL, ITEM_TYPE,
                 ITEM_STATUS, ORDER_BODY_ID
              ) VALUES (
                 rq.bill_id, rq.rep_period_id, Pk02_Poid.Next_item_id, rq.order_id,
                 Pk00_Const.c_SERVICE_OP_LOCAL, Pk00_Const.c_SUBSRV_MIN,
                 Pk00_Const.c_CHARGE_TYPE_MIN, v_charge_value,
                 v_period_from, v_period_to, 'N', Pk00_Const.c_ITEM_TYPE_BILL,
                 Pk00_Const.c_ITEM_STATE_OPEN, rq.order_body_id
              );
              --
              Pk01_Syslog.Write_msg('Bill_id='||rq.bill_id||' RR=2431 - charged', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );          
          END IF;
       END IF;
       v_count := v_count + 1;
    END LOOP;

    PK30_BILLING_QUEUE.Close_task(p_task_id => v_task_id);
    --
    Pk01_Syslog.Write_msg('Stop. '||v_count||' rows deleted', c_PkgName||'.'||v_prcName, Pk01_Syslog.L_info );
    --    
EXCEPTION
    WHEN OTHERS THEN
        Pk01_Syslog.raise_Exception('Stop.ERROR', c_PkgName||'.'||v_prcName );
END;



-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
--     В С П О М О Г А Т Е Л Ь Н Ы Е   Ф У Н К Ц И И
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Функция конвертации валюты тарифа в рубли
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
FUNCTION Currency_rate(
         p_value       IN NUMBER,
         p_currency_id IN INTEGER, 
         p_date_rate   IN DATE
  ) RETURN NUMBER
IS 
    v_prcName   CONSTANT VARCHAR2(30) := 'Currency_rate';
    v_rubles    NUMBER;
BEGIN
    IF p_currency_id = Pk00_Const.c_CURRENCY_RUB THEN
        -- рубли
        v_rubles := p_value;
    ELSIF p_currency_id = Pk00_Const.c_CURRENCY_YE_FIX THEN 
        -- фиксированный курс 28.6 руб
        v_rubles := p_value * 28.6;
    ELSE
        -- доллар США, евро - конвертация на указанную дату
        SELECT RATE_VALUE 
          INTO v_rubles
          FROM CURRENCY_RATE_T
         WHERE CURRENCY_ID = p_currency_id
           AND DATE_RATE = TRUNC(p_date_rate);
    END IF;
    RETURN v_rubles;
EXCEPTION 
    WHEN NO_DATA_FOUND THEN
      IF p_currency_id IN (Pk00_Const.c_CURRENCY_USD, Pk00_Const.c_CURRENCY_EUR) THEN
          Pk01_Syslog.raise_Exception('Unknown currency_id='||p_currency_id, c_PkgName||'.'||v_prcName );
      ELSE
          Pk01_Syslog.raise_Exception('No data found for currency_id='||p_currency_id||
                                      ', date='||TO_CHAR(p_date_rate,'dd.mm.yyyy')
                                       , c_PkgName||'.'||v_prcName );
      END IF;
    WHEN OTHERS THEN
      Pk01_Syslog.raise_Exception('ERROR', c_PkgName||'.'||v_prcName );
END;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
-- Функция вычисления понижающего коэффициента к ежемесячному платежу, 
-- по кол-ву дней, когда услуга реально предоставлялась
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
FUNCTION Period_ratio(
         p_period_id     IN INTEGER,
         p_order_body_id IN INTEGER
  ) RETURN NUMBER
IS 
    v_prcName  CONSTANT VARCHAR2(30) := 'Month_ratio';
    v_ratio    NUMBER;
    v_ord_days NUMBER; 
    v_mon_days NUMBER;
    v_lck_days NUMBER;
    v_order_id INTEGER;
BEGIN
    --
    -- получаем кол-во дней в которые оказывалась услуга по заказу
    SELECT ORDER_ID, ROUND(DATE_TO-DATE_FROM) ORD_DAYS, MON_DAYS
      INTO v_order_id, v_ord_days, v_mon_days
      FROM ( 
        SELECT 
            O.ORDER_ID,
            TRUNC(
               CASE
                  WHEN GREATEST(O.DATE_FROM, OB.DATE_FROM) <= P.PERIOD_FROM  
                  THEN P.PERIOD_FROM ELSE GREATEST(O.DATE_FROM, OB.DATE_FROM) 
               END
            ) DATE_FROM,             -- yyyy.mm.dd 00:00:00
            TRUNC(
               CASE
                  WHEN LEAST(NVL(O.DATE_TO,P.PERIOD_TO), NVL(OB.DATE_TO,P.PERIOD_TO)) >= P.PERIOD_TO  
                  THEN P.PERIOD_TO  ELSE LEAST(NVL(O.DATE_TO,P.PERIOD_TO), NVL(OB.DATE_TO,P.PERIOD_TO))
               END
            ) + 86399/86400 DATE_TO, -- yyyy.mm.dd 23:59:59
            ROUND(P.PERIOD_TO - P.PERIOD_FROM) MON_DAYS
          FROM ORDER_T O, ORDER_BODY_T OB, PERIOD_T P
         WHERE OB.ORDER_ID = O.ORDER_ID
           AND OB.ORDER_BODY_ID = p_order_body_id
           AND P.PERIOD_ID      = p_period_id
    );
    --
    -- получаем кол-во дней периода, когда заказ был заблокирован
    SELECT NVL(ROUND(SUM(LOCK_DAYS)),0) LCK_DAYS
      INTO v_lck_days
      FROM (
        SELECT CASE 
                -- заблокирован весь месяц:  DATE_FROM---[-------]---DATE_TO
                WHEN L.DATE_FROM <= P.PERIOD_FROM 
                 AND (P.PERIOD_TO <= L.DATE_TO OR L.DATE_TO IS NULL) 
                THEN P.PERIOD_TO - P.PERIOD_FROM
                -- заблокирован внутри месяца: [--DATE_FROM-----DATE_TO--]
                WHEN P.PERIOD_FROM < L.DATE_FROM 
                 AND L.DATE_TO < P.PERIOD_TO 
                THEN L.DATE_TO - L.DATE_FROM
                -- заблокирован в предыдущем периоде, открыт в текущем: ---DATE_FROM-- [---DATE_TO---]
                WHEN L.DATE_FROM <= P.PERIOD_FROM 
                 AND L.DATE_TO < P.PERIOD_TO 
                THEN L.DATE_TO - P.PERIOD_FROM
                -- заблокирован в текущем периоде, и остается до конца периода:---[--DATE_FROM--]---DATE_TO---  
                WHEN P.PERIOD_FROM < L.DATE_FROM  
                 AND (P.PERIOD_TO <= L.DATE_TO OR L.DATE_TO IS NULL)
                THEN P.PERIOD_TO - L.DATE_FROM
                -- возможем некорректный ввод
                ELSE 0
               END LOCK_DAYS
          FROM ORDER_LOCK_T L, PERIOD_T P
        WHERE L.DATE_FROM    <= P.PERIOD_TO                     -- только блокировки 
          AND (L.DATE_TO IS NULL OR P.PERIOD_FROM <= L.DATE_TO) -- действовавшие в периоде
          AND L.ORDER_ID      = v_order_id
          AND P.PERIOD_ID     = p_period_id
    );
    -- вычисляем понижающий коэффициент
    IF v_ord_days < v_lck_days THEN 
        v_ratio := 0;
    ELSE
        v_ratio := (v_ord_days - v_lck_days)/v_mon_days;
    END IF;
    RETURN v_ratio;
EXCEPTION 
    WHEN OTHERS THEN
      Pk01_Syslog.raise_Exception('ERROR', c_PkgName||'.'||v_prcName );
END;

END PK36_BILLING_FIXRATE_OLD;
/
